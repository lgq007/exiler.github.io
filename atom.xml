<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>exiler&#39;s Blog</title>
  
  <subtitle>Code builds world !</subtitle>
  <link href="http://lgq007.github.io/atom.xml" rel="self"/>
  
  <link href="http://lgq007.github.io/"/>
  <updated>2023-12-06T12:58:53.903Z</updated>
  <id>http://lgq007.github.io/</id>
  
  <author>
    <name>exiler</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Docker入门</title>
    <link href="http://lgq007.github.io/2023/12/25/Docker%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5/"/>
    <id>http://lgq007.github.io/2023/12/25/Docker%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5/</id>
    <published>2023-12-25T01:13:54.000Z</published>
    <updated>2023-12-06T12:58:53.903Z</updated>
    
    <content type="html"><![CDATA[<p>Docker是基于go语言开发实现，基于Linux内核的<code>cgroup</code>和<code>namespace</code>，以及<code>OverlayFS</code>类的<code>Union FS</code>等技术，对<strong>进程</strong>进行封装隔离，位于<code>操作系统层面的虚拟化技术</code>。由于隔离的进程独立于其他的隔离的进程，也称之为容器，Docker充当容器引擎。Docker是一个划时代的开源项目，它彻底释放了计算虚拟化的威力！</p><p><img src="/2023/12/25/Docker%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5/111111.png"></p><p>Docker在容器的基础之上，进一步提高了封装技术，做到从文件系、网络互连到进程隔离等等，极大的简化了容器的创建和维护，使得Docker技术比虚拟机技术更为轻便、快捷。</p><h1 id="docker与virtual-machines技术的区别">Docker与VirtualMachines技术的区别</h1><figure><img src="/2023/12/25/Docker%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5/virtualization.png" alt="传统虚拟化"><figcaption aria-hidden="true">传统虚拟化</figcaption></figure><ul><li>从图中可以看出，在虚拟机技术中，要先在宿主机操作系统中虚拟出一套硬件之后，在其上运行一个完整的操作系统，然后在此操作系统上运行所需的应用进程。</li></ul><figure><img src="/2023/12/25/Docker%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5/docker.png" alt="Docker"><figcaption aria-hidden="true">Docker</figcaption></figure><ul><li>而在容器中，应用进程直接运行于宿主的内核，容器没有自己的内核，也没有进行硬件虚拟，节约了大量的资源。</li></ul><table><thead><tr class="header"><th style="text-align: center;">特性</th><th style="text-align: center;">容器</th><th style="text-align: center;">虚拟机</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">启动速度</td><td style="text-align: center;">秒级</td><td style="text-align: center;">分钟级</td></tr><tr class="even"><td style="text-align: center;">硬盘使用</td><td style="text-align: center;">一般为MB</td><td style="text-align: center;">一般为GB</td></tr><tr class="odd"><td style="text-align: center;">性能</td><td style="text-align: center;">接近原生</td><td style="text-align: center;">更弱</td></tr><tr class="even"><td style="text-align: center;">系统支持量</td><td style="text-align: center;">单机支持上千个容器</td><td style="text-align: center;">一般几十个</td></tr></tbody></table><h2 id="doker的优点">Doker的优点</h2><h3 id="更高效的利用系统资源">更高效的利用系统资源</h3><p>容器不需要进行硬件虚拟化以及运行完整的操作系统的额外开销，Docker对系统资源的利用率更高。</p><h3 id="更快速的启动时间">更快速的启动时间</h3><p>容器应用运行在宿主机中，无需额外的时间开销，可以做到秒级的启动时间</p><h3 id="一致的运行环境">一致的运行环境</h3><p>在应用开发中，使用Docker中的镜像可以提供出除内核外的完整的运行时的环境，确保应用运行环境的一致性。</p><h3 id="持续交付和部署">持续交付和部署</h3><p>使用 <code>Docker</code>可以通过定制应用镜像来实现持续集成、持续交付、部署。开发人员通过<code>Dockerfile</code>来进行镜像构建，运维人员可以直接在生产环境中快速部署镜像。</p><p><code>Dockerfile</code>使镜像的构建透明化，方便使用镜像的人员理解运行时所需条件，更快的部署镜像。</p><h3 id="更轻松的迁移">更轻松的迁移</h3><p>由于 <code>Docker</code>确保了执行环境的一致性，使得应用的迁移更加容易。<code>Docker</code>可以在很多平台上运行，无论是物理机、虚拟机、公有云、私有云，甚至是笔记本，其运行结果是一致的。</p><h3 id="更轻松的维护和扩展">更轻松的维护和扩展</h3><p><code>Docker</code>使用的分层存储以及镜像的技术，使得应用重复部分的复用更为容易，此外，<code>Docker</code>团队同各个开源项目团队一起维护了一大批高质量的 <a href="https://hub.docker.com/search/?type=image&amp;image_filter=official">官方镜像</a>，既可以直接使用，也可以在此基础上定制镜像</p><h1 id="docker部署及配置">Docker部署及配置</h1><ul><li>安装Docker工具</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ss -anptu</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;Docker是基于go语言开发实现，基于Linux内核的&lt;code&gt;cgroup&lt;/code&gt;和&lt;code&gt;namespace&lt;/code&gt;，以及&lt;code&gt;OverlayFS&lt;/code&gt;类的&lt;code&gt;Union FS&lt;/code&gt;等技术，对&lt;strong&gt;进程&lt;/strong&gt;进行封装隔离，位于&lt;code&gt;操作系统层面的虚拟化技术&lt;/code&gt;。由于隔离的进程独立于其他的隔离的进程，也称之为容器，Docker充当容器引擎。Docker是一个划时代的开源项目，它彻底释放了计算虚拟化的威力！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2023/12/25/Docker%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5/111111.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;Docker在容器的基础之上，进一步提高了封装技术，做到从文件系、网络互连到进程隔离等等，极大的简化了容器的创建和维护，使得Docker技术比虚拟机技术更为轻便、快捷。&lt;/p&gt;
&lt;h1 id=&quot;docker与virtual-machines技术的区别&quot;&gt;Docker与Virtual
Machines技术的区别&lt;/h1&gt;
&lt;figure&gt;
&lt;img src=&quot;/2023/12/25/Docker%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5/virtualization.png&quot; alt=&quot;传统虚拟化&quot;&gt;
&lt;figcaption aria-hidden=&quot;true&quot;&gt;传统虚拟化&lt;/figcaption&gt;
&lt;/figure&gt;</summary>
    
    
    
    <category term="容器" scheme="http://lgq007.github.io/categories/%E5%AE%B9%E5%99%A8/"/>
    
    
    <category term="Docker" scheme="http://lgq007.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>算法笔记(一)：并查集</title>
    <link href="http://lgq007.github.io/2023/12/07/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-%E4%B8%80-%EF%BC%9A%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    <id>http://lgq007.github.io/2023/12/07/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-%E4%B8%80-%EF%BC%9A%E5%B9%B6%E6%9F%A5%E9%9B%86/</id>
    <published>2023-12-07T13:17:56.000Z</published>
    <updated>2023-12-07T14:59:30.240Z</updated>
    
    <content type="html"><![CDATA[<p>并查集是一种精巧且实用的<strong>数据结构</strong>，常用于处理不相交集合之间的合并、查询问题。</p><ul><li>合并(Union)：把两个不相交的集合合并为一个集合</li><li>查询(Find)：查询两个元素是否在同一集合中</li></ul><figure><img src="/2023/12/07/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-%E4%B8%80-%EF%BC%9A%E5%B9%B6%E6%9F%A5%E9%9B%86/示例图片1.png" alt="示例图片1"><figcaption aria-hidden="true">示例图片1</figcaption></figure><p>这里不必把并查集想的太过于复杂，其实这种数据结构用一个一维数组即可实现，<strong>并查集的重要思想在于用集合中的一个特别的元素（一般是一个集合中的祖先，也称为根节点）代表整个集合，参与与其他元素或集合之间的操作。</strong></p><h1 id="并查集的初始化">并查集的初始化</h1><p>假设有编号为1，2，3，4，....，n的元素，我们用一个一维数组fa[]来存储每个元素的父节点（因为每个元素仅有一个父节点，这种方式是可行的）。初始化时，每个元素的父节点均为该元素本身。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> fa[maxn]; <span class="comment">//定义一维数组</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">    fa[i]=i;  <span class="comment">//赋予每个元素父节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如，这时候我们初始化时n=6个，此时可以抽象出图形：</p><figure><img src="/2023/12/07/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-%E4%B8%80-%EF%BC%9A%E5%B9%B6%E6%9F%A5%E9%9B%86/image-20231207214110646.png" alt="示例图片2"><figcaption aria-hidden="true">示例图片2</figcaption></figure><ul><li>这时每个元素的父节点均指向它本身。</li></ul><h1 id="并查集的查询">并查集的查询</h1><ul><li>并查集的查找是为了找到该集合中的祖先。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//无路径压缩</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(i == fa[i]) <span class="keyword">return</span> i;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">find</span>(<span class="built_in">fa</span>(i));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//递归实现查找祖先（祖先的标志是父节点是本身）</span></span><br></pre></td></tr></table></figure><figure><img src="/2023/12/07/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-%E4%B8%80-%EF%BC%9A%E5%B9%B6%E6%9F%A5%E9%9B%86/v2-cca3ddf5806a221201ed78caf1d27041_1440w.webp" alt="示例图片3"><figcaption aria-hidden="true">示例图片3</figcaption></figure><ul><li>在此集合中的根节点为1号元素，通过上述代码可完成对1号元素的查找</li></ul><h1 id="并查集的合并">并查集的合并</h1><ul><li>所谓并查集的合并，<strong>本质上就是将两个子集中的代表元素相连</strong>，这样可以形成一个大集合</li></ul><figure><img src="/2023/12/07/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-%E4%B8%80-%EF%BC%9A%E5%B9%B6%E6%9F%A5%E9%9B%86/v2-3c353bc781c7f3553079d541a9cfdc28_1440w.webp" alt="示例图片4"><figcaption aria-hidden="true">示例图片4</figcaption></figure><p>比如在这幅图中有</p><ul><li>子集{1，2，3}，代表元素是1号元素</li><li>子集{4，5，6}，代表元素是4号元素</li></ul><p><strong>对这两个子集的合并本质上就是让两个子集的代表元素：2号元素与4号元素相连</strong>，这样就构成了一个新的大集合，假设1号元素是祖先：</p><figure><img src="/2023/12/07/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-%E4%B8%80-%EF%BC%9A%E5%B9%B6%E6%9F%A5%E9%9B%86/v2-6362d8b13705d5ba17b19cdeee453022_1440w.webp" alt="示例图片5"><figcaption aria-hidden="true">示例图片5</figcaption></figure><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">union</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span></span>&#123;</span><br><span class="line">  <span class="type">int</span> i_fa = <span class="built_in">find</span>(i); <span class="comment">//i的祖先；</span></span><br><span class="line">  <span class="type">int</span> j_fa = <span class="built_in">find</span>(j); <span class="comment">//j的祖先；</span></span><br><span class="line">  </span><br><span class="line">  fa[i_fa] = j_fa; <span class="comment">//将i的祖先指向j的祖先；</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="采用压缩路径方式的查询方式">采用压缩路径方式的查询方式</h1><p>如果整个集合中的元素上万：1--&gt;2--&gt;3--&gt;4--&gt;...--&gt;100000;</p><p>这个时候如果直接调用函数union(2，100001)，此时需要查询上万次，代码的运行可能会超时，因为我们可以采用路径压缩的方式，将这种<strong>类似于线性表的结构大致转化为两层的树状结构：</strong></p><figure><img src="/2023/12/07/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-%E4%B8%80-%EF%BC%9A%E5%B9%B6%E6%9F%A5%E9%9B%86/image-20231207221844313.png" alt="示例图片6"><figcaption aria-hidden="true">示例图片6</figcaption></figure><ul><li>这时对于无论多少元素的集合，只需查询一次，便可得到祖先元素</li></ul><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(i)</span></span>&#123;  <span class="comment">//路径压缩版本</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(i == <span class="built_in">find</span>(i)) <span class="keyword">return</span> i;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    fa[i] = <span class="built_in">find</span>(fa[i]);</span><br><span class="line">  <span class="keyword">return</span> fa[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：</p><ul><li>有些人可能有一个误解，以为路径压缩优化后，并查集始终都是一个<strong>菊花图</strong>（只有两层的树的俗称）。但其实，<strong>由于路径压缩只在查询时进行，也只压缩一条路径</strong>，所以并查集最终的结构仍然可能是比较复杂的。</li></ul><h1 id="示例求团伙数量">示例：求团伙数量</h1><p><strong>【问题描述】</strong>第一行两个数：n，m。其中n表示强盗的个数，m表示警方搜集到的线索。接下来m行，每行两个整数a，b表示a强盗和b强盗是同伙。问一共有多少个团伙？</p><p><strong>【样例输入】</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">10 9</span><br><span class="line">1 2</span><br><span class="line">3 4</span><br><span class="line">5 2</span><br><span class="line">4 6</span><br><span class="line">2 6</span><br><span class="line">8 7</span><br><span class="line">9 7</span><br><span class="line">1 6</span><br><span class="line">2 4</span><br></pre></td></tr></table></figure><p><strong>【样例输出】</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><p>【代码示例】</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">100</span>;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">fa</span><span class="params">(maxn)</span></span>;</span><br><span class="line"><span class="type">int</span> ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123; <span class="comment">//初始化</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">fa[i] = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123; <span class="comment">//查找祖先</span></span><br><span class="line"><span class="keyword">if</span> (fa[i] == i) <span class="keyword">return</span> i;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">fa[i] = <span class="built_in">find</span>(fa[i]);</span><br><span class="line"><span class="keyword">return</span> fa[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merage</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> i_fa = <span class="built_in">find</span>(i);</span><br><span class="line"><span class="type">int</span> j_fa = <span class="built_in">find</span>(j);</span><br><span class="line"><span class="keyword">if</span> (i_fa != j_fa) &#123;</span><br><span class="line">fa[<span class="built_in">find</span>(i)] = <span class="built_in">find</span>(j);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line"><span class="built_in">init</span>(n);  <span class="comment">//初始化</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> p, q;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">cin &gt;&gt; p &gt;&gt; q;</span><br><span class="line"><span class="built_in">merage</span>(p, q);  <span class="comment">//将元素连接</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (i == <span class="built_in">find</span>(i))  <span class="comment">//计算连通子图树，即集合数</span></span><br><span class="line">ans++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内容参考：</p><p><a href="https://zhuanlan.zhihu.com/p/93647900">算法学习笔记(1) :并查集 - 知乎 (zhihu.com)</a></p><p><a href="https://blog.csdn.net/hnjzsyjyj/article/details/120120591">求团伙数量← 并查集_hnjzsyjyj的博客-CSDN博客</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;并查集是一种精巧且实用的&lt;strong&gt;数据结构&lt;/strong&gt;，常用于处理不相交集合之间的合并、查询问题。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;合并(Union)：把两个不相交的集合合并为一个集合&lt;/li&gt;
&lt;li&gt;查询(Find)：查询两个元素是否在同一集合中&lt;/li&gt;
&lt;/ul&gt;
&lt;figure&gt;
&lt;img src=&quot;/2023/12/07/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-%E4%B8%80-%EF%BC%9A%E5%B9%B6%E6%9F%A5%E9%9B%86/示例图片1.png&quot; alt=&quot;示例图片1&quot;&gt;
&lt;figcaption aria-hidden=&quot;true&quot;&gt;示例图片1&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;这里不必把并查集想的太过于复杂，其实这种数据结构用一个一维数组即可实现，&lt;strong&gt;并查集的重要思想在于用集合中的一个特别的元素（一般是一个集合中的祖先，也称为根节点）代表整个集合，参与与其他元素或集合之间的操作。&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&quot;并查集的初始化&quot;&gt;并查集的初始化&lt;/h1&gt;</summary>
    
    
    
    <category term="数据结构" scheme="http://lgq007.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="图" scheme="http://lgq007.github.io/tags/%E5%9B%BE/"/>
    
    <category term="并查集" scheme="http://lgq007.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>在Docker中部署Hadoop完全分布式集群</title>
    <link href="http://lgq007.github.io/2023/12/05/%E5%9C%A8Docker%E4%B8%AD%E9%83%A8%E7%BD%B2Hadoop%E5%AE%8C%E5%85%A8%E5%88%86%E5%B8%83%E5%BC%8F%E9%9B%86%E7%BE%A4/"/>
    <id>http://lgq007.github.io/2023/12/05/%E5%9C%A8Docker%E4%B8%AD%E9%83%A8%E7%BD%B2Hadoop%E5%AE%8C%E5%85%A8%E5%88%86%E5%B8%83%E5%BC%8F%E9%9B%86%E7%BE%A4/</id>
    <published>2023-12-05T15:18:38.000Z</published>
    <updated>2023-12-05T15:18:38.952Z</updated>
    
    <content type="html"><![CDATA[]]></content>
    
    
      
      
    <summary type="html">
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>排序算法</title>
    <link href="http://lgq007.github.io/2023/12/05/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <id>http://lgq007.github.io/2023/12/05/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</id>
    <published>2023-12-05T15:18:04.000Z</published>
    <updated>2023-12-05T15:18:04.282Z</updated>
    
    <content type="html"><![CDATA[]]></content>
    
    
      
      
    <summary type="html">
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Tree-2</title>
    <link href="http://lgq007.github.io/2023/10/22/Tree-2/"/>
    <id>http://lgq007.github.io/2023/10/22/Tree-2/</id>
    <published>2023-10-22T09:50:03.000Z</published>
    <updated>2023-12-05T15:00:16.483Z</updated>
    
    <content type="html"><![CDATA[<h1 id="树的常考性质">树的常考性质</h1><figure><img src="/2023/10/22/Tree-2/image-20231022174230215.png" alt="image-20231022174230215"><figcaption aria-hidden="true">image-20231022174230215</figcaption></figure><hr><span id="more"></span><h2 id="结点数-总度数-1">结点数 = 总度数 + 1</h2><ul><li>结点的度：结点有几个孩子（分支）</li></ul><figure><img src="/2023/10/22/Tree-2/image-20231022162720388.png" alt="image-20231022162720388"><figcaption aria-hidden="true">image-20231022162720388</figcaption></figure><ol type="1"><li><strong>结点数（N）</strong>：树中的结点数表示树中包含的总结点数量，包括根结点和所有子结点。</li><li><strong>总度数（Σdeg）</strong>：总度数是指树中所有结点的度（子结点的数量）之和。它表示了树中的所有分支总数。</li><li><strong>根结点的度和叶子结点的度</strong>：在一棵树中，根结点的度通常是1或更大，因为根结点可以有子结点。叶子结点的度通常是0，因为它们没有子结点。</li></ol><p>现在来理解这个性质：</p><p>树的性质规定，一棵树必须满足以下条件：</p><ul><li><strong><em>每个结点至少有一个子结点（包括根结点）。</em></strong></li><li><strong><em>结点之间不能形成循环（无环）。</em></strong></li></ul><p>由于根结点至少有一个子结点，它的度至少为1。其他非叶子结点的度也大于等于1，因为它们也有子结点。叶子结点的度是0。</p><p>所以，如果我们计算树中每个结点的度，然后将它们相加，总度数等于树的结点数减去1。这是因为根结点的度不需要被计算在总度数中。所以可以表示为：</p><p>总度数 = 结点数 - 1</p><hr><h2 id="度为m的树m叉树的区别">度为m的树、m叉树的区别</h2><ul><li>树的度：各结点的度的最大值</li><li>m叉树：每个结点最多只能有m个孩子的树</li></ul><table><colgroup><col style="width: 50%"><col style="width: 50%"></colgroup><thead><tr class="header"><th style="text-align: center;">度为m的树</th><th style="text-align: center;">m叉树</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">任意结点的度 <strong><em>≤m</em></strong>（最多m个孩子）</td><td style="text-align: center;">任意结点的度 <strong><em>≤m</em></strong>（最多m个孩子）</td></tr><tr class="even"><td style="text-align: center;">至少有一个结点度 <strong><em>=m</em></strong>（有m个孩子）</td><td style="text-align: center;">允许所有结点的度都 <strong><em>&lt;m</em></strong>（m叉空树）</td></tr><tr class="odd"><td style="text-align: center;">一定是非空树，至少有<strong><em>m+1</em></strong> 个结点</td><td style="text-align: center;">可以是空树</td></tr></tbody></table><figure><img src="/2023/10/22/Tree-2/image-20231022164612919.png" alt="image-20231022164612919"><figcaption aria-hidden="true">image-20231022164612919</figcaption></figure><hr><h2 id="度为m的树与m叉树每层至多有mi-1个结点i-1">度为m的树与m叉树每层至多有m<sup>i-1</sup>个结点（<em>i≥ 1</em>）</h2><figure><img src="/2023/10/22/Tree-2/image-20231022170648868.png" alt="image-20231022170648868"><figcaption aria-hidden="true">image-20231022170648868</figcaption></figure><hr><h2 id="高度为h的m叉树至多有多少结点">高度为h的m叉树至多有多少结点？</h2><figure><img src="/2023/10/22/Tree-2/image-20231022171803394.png" alt="image-20231022171803394"><figcaption aria-hidden="true">image-20231022171803394</figcaption></figure><p>当树的每一层结点数均为最大时，此树有最大结点：</p><p><span class="math display">\[m^0 + m^1 + m^2 + m^3 + ...  + m^{h-1}\]</span> 即：</p><p><span class="math display">\[S = \frac{m^{h} - 1}{m-1}\]</span> <strong><em>(h从0开始计数)</em></strong></p><hr><h2 id="高度为h的m叉树至少有h个结点高度为h度为m的树至少有hm-1个结点">高度为<code>h</code>的<code>m</code>叉树至少有<code>h</code>个结点，高度为<code>h</code>、度为<code>m</code>的树至少有<code>h+m-1</code>个结点</h2><figure><img src="/2023/10/22/Tree-2/image-20231022172752895.png" alt="image-20231022172752895"><figcaption aria-hidden="true">image-20231022172752895</figcaption></figure><hr><h2 id="具有n个结点的m叉树的最小高度为logm-n-m-1-1">具有<code>n</code>个结点的<code>m</code>叉树的最小高度为log<sub>m</sub>(n (m-1) + 1)</h2><p>高度最小的情况：所有结点都有m个孩子</p><p>前h-1层最多的结点数： <span class="math display">\[\frac{m^{h-1}-1}{m-1}\]</span> 前h曾最多的结点数： <span class="math display">\[\frac{m^{h}-1}{m-1}\]</span> 故： <span class="math display">\[\frac{m^{h-1}-1}{m-1}&lt;n≤\frac{m^{h}-1}{m-1}\]</span></p><p><span class="math display">\[2. m^{h-1}&lt;n(m-1)+1≤m^h\]</span></p><p><span class="math display">\[h-1&lt;log_{m}(n(m-1)+1)≤h\]</span></p><p>故： <span class="math display">\[h_{min}=log_{m}(n(m-1)+1)\]</span></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;树的常考性质&quot;&gt;树的常考性质&lt;/h1&gt;
&lt;figure&gt;
&lt;img src=&quot;/2023/10/22/Tree-2/image-20231022174230215.png&quot; alt=&quot;image-20231022174230215&quot;&gt;
&lt;figcaption aria-hidden=&quot;true&quot;&gt;image-20231022174230215&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;hr&gt;</summary>
    
    
    
    <category term="数据结构" scheme="http://lgq007.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="树" scheme="http://lgq007.github.io/tags/%E6%A0%91/"/>
    
    <category term="图" scheme="http://lgq007.github.io/tags/%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>Tree-1</title>
    <link href="http://lgq007.github.io/2023/10/22/Tree-1/"/>
    <id>http://lgq007.github.io/2023/10/22/Tree-1/</id>
    <published>2023-10-22T08:05:17.000Z</published>
    <updated>2023-10-22T08:07:33.139Z</updated>
    
    <content type="html"><![CDATA[<h1 id="树tree">树（Tree）</h1><blockquote><p>图是计算机科学与数学领域中一个重要的数据结构，而树是一种特殊类型的图</p></blockquote><p>树有以下特点：</p><ol type="1"><li><strong><em>树是一种分层的数据结构，由节点（Node）和边（Edge）组成。</em></strong></li><li><strong><em>树是一种没有环路的图，即无环图，并且它是连通的（每两个节点之间都存在路径）。</em></strong></li><li><strong><em>树通常有一个根节点（Root），从根节点出发，可以沿着边到达其他节点。</em></strong></li><li><strong><em>树中每个节点通常有一个父节点（除去根节点），可以用零个或多个子节点。</em></strong></li><li><strong><em>树可以分为多个子树，每个子树也是一颗树。</em></strong></li></ol><hr><span id="more"></span><p>图（Graph）：</p><ol type="1"><li>图是一种更一般化的数据结构，它由节点和边组成，节点之间的连接关系可以非常复杂，可以包含环路。</li><li>图分为有向图（Directed Graph）和无向图（UndirectedGraph）两种主要类型。在有向图中，边有方向，而在无向图中，边没有方向。</li><li>图可以是连通的，也可以是不连通的。连通的图中，从任意一个节点都可以到达其他节点。</li><li>图中的节点之间的关系可以是单向的，双向的，带权重的等，这使得图能够表示各种复杂的关系网络。</li></ol><hr><p>树与图的关系：</p><ol type="1"><li>树是图的一种特殊情况，具有一些额外的约束条件，如无环和连通性。</li><li>树通常表示层次结构，比如文件系统，组织结构等，而图通常用于表示更一般的关系网络，如社交网络，交通网络等。</li><li>图可以转化为树，例如，可以从一个有向图中选择一个节点作为根节点，构建一棵树，这种书被称为生成树（SpanningTree）。</li></ol><hr><p><strong>树在层次性结构和递归算法中特别有用，而图用于更广泛的关系网络建模。</strong></p><hr><p>文件系统中的树：</p><figure><img src="/2023/10/22/Tree-1/image-20231021210547562.png" alt="image-20231021210547562"><figcaption aria-hidden="true">image-20231021210547562</figcaption></figure><hr><h1 id="树的基本概念及基本术语">树的基本概念及基本术语</h1><figure><img src="/2023/10/22/Tree-1/image-20231021231433613.png" alt="image-20231021231433613"><figcaption aria-hidden="true">image-20231021231433613</figcaption></figure><p>## 树的基本概念</p><figure><img src="/2023/10/22/Tree-1/image-20231021211251341.png" alt="image-20231021211251341"><figcaption aria-hidden="true">image-20231021211251341</figcaption></figure><ul><li>空树：——结点数为<strong><em>0</em></strong>的树</li><li>非空树的特性：<ul><li>有且仅有一个根结点</li><li>没有后继的结点称为“叶子结点”（或终端结点）</li><li>有后继的结点称为“分支结点”（或非终端结点）</li><li><strong><em>除了根节点外，任何一个结点都有且仅有一个前驱结点</em></strong></li><li>每个结点可以有0个或多个后继结点</li></ul></li></ul><hr><p>以下的数据结构不是树：</p><figure><img src="/2023/10/22/Tree-1/image-20231021212155424.png" alt="image-20231021212155424"><figcaption aria-hidden="true">image-20231021212155424</figcaption></figure><hr><p>树是<strong><em>n</em></strong>（<strong><em>n≥0</em></strong>）个<strong><em>结点</em></strong>的有限集合，<strong><em>n=0时，称为空树</em></strong>，这是一种特殊情况。在任意一颗非空树中应满足：</p><p>1）有且仅有一个特定的称为<strong><em>根</em></strong>的结点</p><p>2）当<strong><em>n&gt;1</em></strong>时，其余节点可分为<strong><em>m（m&gt;0）</em></strong>个互不相交的有限集合<strong><em>T<sub>1</sub>,T<sub>2</sub>,T<sub>3</sub>,...,T<sub>m</sub></em></strong>，其中每个集合本身又是一棵树，并且称为根节点的子树。</p><figure><img src="/2023/10/22/Tree-1/image-20231021215456155.png" alt="image-20231021215456155"><figcaption aria-hidden="true">image-20231021215456155</figcaption></figure><figure><img src="/2023/10/22/Tree-1/image-20231021215626757.png" alt="image-20231021215626757"><figcaption aria-hidden="true">image-20231021215626757</figcaption></figure><h3 id="树形逻辑结构的应用">树形逻辑结构的应用</h3><figure><img src="/2023/10/22/Tree-1/image-20231021215839494.png" alt="image-20231021215839494"><figcaption aria-hidden="true">image-20231021215839494</figcaption></figure><h3 id="结点之间的关系描述">结点之间的关系描述</h3><figure><img src="/2023/10/22/Tree-1/image-20231021215959151.png" alt="image-20231021215959151"><figcaption aria-hidden="true">image-20231021215959151</figcaption></figure><ul><li>祖先结点（Ancestors）：<strong><em>在树中从一个结点到根节点的路径上的所有节点，也就是，一个结点的祖先结点就是其所有上层结点，一直到根节点。</em></strong>以<em>'M'</em>为例子，<em>'H'、'三叔'、'爷爷'</em>就是它的祖先节点。</li><li>子孙结点（Descendants）：<strong><em>在树中从某个结点向下遍历树，包括所有通过边与该结点相连的后代节点。一个结点的子孙结点是其所有下层节点，包括直接子节点的子孙结点。</em></strong>以<em>'父亲'</em>为例，<em>'你'、'F'、'K'、'L'</em>都是其子孙结点。</li><li>双亲结点（父结点，Parent）：<strong><em>在树中与某个结点直接相连的上层结点。</em></strong>以<em>'你'</em>为例，<em>'父亲'</em>便是其双亲结点。</li><li>孩子结点（Childs）：<strong><em>在树中与某个结点直接相连的下层结点。</em></strong>以<em>'父亲'</em>为例，<em>'你'</em>和<em>'F'</em>就是其孩子结点。</li><li>兄弟结点（Sibling）：<strong>在树中与同一个双亲结点相连的结点，也就是在同一层次的结点。</strong>兄弟结点具有相同的双亲结点。以<em>'你'</em>为例，<em>'F'</em>便是其兄弟结点。</li><li>堂兄弟结点（Cousins）：在树中具有不同的双亲结点，但它们的双亲结点是兄弟或姐妹。堂兄弟结点通常在不同分支下，但它们共享一个祖父结点。</li></ul><hr><h4 id="q1什么是两个结点之间的路径">Q1：什么是两个结点之间的路径？</h4><p><strong><em>两个结点之间的路径是指从一个结点到另一个结点经过的边的序列。</em></strong>在树或图中，路径表示了从一个结点到另一个结点的连接方式。这个路径是由一系列边组成的，这些边连接了沿途的结点。路径可以是直接的（只有一条边）也可以是间接的（多条边组成）。<strong><em>路径的存在意味着从一个结点到另一个结点有可达性。</em></strong></p><h4 id="q2什么是路径长度">Q2：什么是路径长度？</h4><p><strong><em>路径长度是指路径上的边的数量</em></strong>，<strong><em>也可以是路径上的边的权重之和（如果边有权重的话）。</em></strong>在许多情况下，路径长度表示从一个结点到另一个结点的距离或代价。如果路径是直接的，路径长度通常是1，如果路径是间接的，路径长度是沿途的边的数量。在带权重的图中，路径长度是路径上所有边的权重之和。路径长度的计算对于许多算法和问题解决方案非常重要，如最短路径问题、最小生成树算法等。</p><hr><h2 id="结点树的属性描述">结点、树的属性描述</h2><figure><img src="/2023/10/22/Tree-1/image-20231021224428477.png" alt="image-20231021224428477"><figcaption aria-hidden="true">image-20231021224428477</figcaption></figure><p>属性：</p><ul><li>结点的层次（深度）——从上往下数：</li></ul><p><strong><em>结点的层次指的是结点在树中的垂直级别或深度。</em></strong>根结点的层次通常被定义为0，而根结点的子结点的层次为1，依此类推。结点的层次可以帮助确定结点在树中的相对位置。</p><ul><li>结点的高度——从下往上数：</li></ul><p><strong><em>结点的高度是从该结点到树中最远叶子结点的最长路径的长度。</em></strong>换句话说，结点的高度表示了以该结点为起点的最长路径的长度。<strong><em>根结点的高度通常被定义为整棵树的高度。</em></strong></p><ul><li>树的高度（深度）——总共多少层：</li></ul><p><strong><em>树的高度是树中任意叶子结点的最长路径的长度。</em></strong>它表示了整棵树的垂直级别或深度。树的高度可以看作是树的层次的最大值，也就是树的最深层次。</p><ul><li>结点的度——有几个孩子（分支）：</li></ul><p><strong>结点的度是指该结点拥有的子结点的数量。</strong>在树中，结点的度可以是0（叶子结点），1（只有一个子结点，通常是根结点），2（拥有两个子结点，通常是二叉树），或更多。<strong><em>结点的度可以帮助确定树的类型，例如二叉树、三叉树等。</em></strong></p><ul><li>树的度——各结点的度的最大值：</li></ul><p><strong><em>树的度是指树中各个结点的度的最大值。树的度表示了树中分支的复杂程度。</em></strong>例如，如果树的度为1，那么它是一棵链式树，如果度为2，它是二叉树，如果度大于2，它是多叉树。</p><hr><h3 id="有序树与无序树">有序树与无序树</h3><ul><li>有序树：逻辑上看，树中各结点的各字数从左到右是有次序的，不能互换</li></ul><figure><img src="/2023/10/22/Tree-1/image-20231021230701007.png" alt="image-20231021230701007"><figcaption aria-hidden="true">image-20231021230701007</figcaption></figure><ul><li>无序树：逻辑上看，树中各结点的各字数从左到右是无次序的，可以互换</li></ul><figure><img src="/2023/10/22/Tree-1/image-20231021230850198.png" alt="image-20231021230850198"><figcaption aria-hidden="true">image-20231021230850198</figcaption></figure><h3 id="树与森林">树与森林</h3><p>森林是<strong><em>m（m≥0）</em></strong>颗互不相交的树的集合，<em>比如全中国所有人家的家谱</em>（<strong><em>m为0，空森林</em></strong>）。</p><figure><img src="/2023/10/22/Tree-1/image-20231021231251345.png" alt="image-20231021231251345"><figcaption aria-hidden="true">image-20231021231251345</figcaption></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;树tree&quot;&gt;树（Tree）&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;图是计算机科学与数学领域中一个重要的数据结构，而树是一种特殊类型的图&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;树有以下特点：&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;&lt;strong&gt;&lt;em&gt;树是一种分层的数据结构，由节点（Node）和边（Edge）组成。&lt;/em&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;em&gt;树是一种没有环路的图，即无环图，并且它是连通的（每两个节点之间都存在路径）。&lt;/em&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;em&gt;树通常有一个根节点（Root），从根节点出发，可以沿着边到达其他节点。&lt;/em&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;em&gt;树中每个节点通常有一个父节点（除去根节点），可以用零个或多个子节点。&lt;/em&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;em&gt;树可以分为多个子树，每个子树也是一颗树。&lt;/em&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;</summary>
    
    
    
    <category term="数据结构" scheme="http://lgq007.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="树" scheme="http://lgq007.github.io/tags/%E6%A0%91/"/>
    
    <category term="图" scheme="http://lgq007.github.io/tags/%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>deepin虚拟机安装</title>
    <link href="http://lgq007.github.io/2023/09/09/deepin%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85/"/>
    <id>http://lgq007.github.io/2023/09/09/deepin%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85/</id>
    <published>2023-09-09T06:29:20.000Z</published>
    <updated>2023-12-05T15:00:34.725Z</updated>
    
    <content type="html"><![CDATA[<h1 id="虚拟机安装">虚拟机安装</h1><p>本文演示虚拟机中安装<code>deepin</code>操作系统，由于windows是闭源的，故不再演示，有兴趣的可以自行在B站找教程。Ubuntu与此类似，可在B站找最新的教程观看。</p><h2 id="准备环境">准备环境</h2><p>下载地址均选择清华大学开源镜像站镜像站</p><ul><li><code>visualbox</code>：<a href="https://mirrors.tuna.tsinghua.edu.cn/virtualbox/virtualbox-Win-latest.exe">点击下载</a></li></ul><p>需要注意的是，有的电脑没有<code>msvc</code>环境，会出现安装报错的情况，这里需要安装<code>visual C++</code>环境：<a href="https://aka.ms/vs/17/release/vc_redist.x64.exe">点击下载</a></p><ul><li><code>deepin</code>：<a href="https://mirrors.tuna.tsinghua.edu.cn/deepin-cd/20.6/deepin-desktop-community-20.6-amd64.iso">点击下载</a>，这里下载的是ISO镜像文件。</li></ul><span id="more"></span><h2 id="安装deepin">安装<code>deepin</code></h2><ol type="1"><li><p>点击新建<img src="/2023/09/09/deepin%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85/image-20230906185336662.png" alt="image-20230906185336662"></p></li><li><p>选择一下：</p></li></ol><figure><img src="/2023/09/09/deepin%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85/image-20230906185708422.png" alt="image-20230906185708422"><figcaption aria-hidden="true">image-20230906185708422</figcaption></figure><ul><li>名称设为英文</li><li>文件夹是指将虚拟机放在那个文件里，推荐装在D盘，节省C盘空间</li><li>虚拟光盘选择下载好的<code>deepin</code>的ISO文件</li></ul><ol start="3" type="1"><li>硬件设置：</li></ol><figure><img src="/2023/09/09/deepin%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85/image-20230906190132464.png" alt="image-20230906190132464"><figcaption aria-hidden="true">image-20230906190132464</figcaption></figure><ul><li>如果仅是普通操作学习命令，内存分配2GB即可，如果有长期使用的想法可以多分配，内存较高的也可以多分配点</li><li>处理器这里要看主机的CPU核数，一般选择4核即可</li></ul><ol start="5" type="1"><li>磁盘分配：</li></ol><figure><img src="/2023/09/09/deepin%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85/image-20230906190208144.png" alt="image-20230906190208144"><figcaption aria-hidden="true">image-20230906190208144</figcaption></figure><p>这里作为演示我分配了50GB，当然有条件的话多多益善，体验感更高。</p><p>然后：</p><figure><img src="/2023/09/09/deepin%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85/image-20230906190306348.png" alt="image-20230906190306348"><figcaption aria-hidden="true">image-20230906190306348</figcaption></figure><p>点击完成。</p><h2 id="启动">启动！</h2><figure><img src="/2023/09/09/deepin%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85/image-20230906190352568.png" alt="image-20230906190352568"><figcaption aria-hidden="true">image-20230906190352568</figcaption></figure><p>点击启动进入安装引导页面：</p><figure><img src="/2023/09/09/deepin%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85/image-20230906190419540.png" alt="image-20230906190419540"><figcaption aria-hidden="true">image-20230906190419540</figcaption></figure><p>等待.......</p><figure><img src="/2023/09/09/deepin%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85/image-20230906190630961.png" alt="image-20230906190630961"><figcaption aria-hidden="true">image-20230906190630961</figcaption></figure><p><strong>选择第一个</strong>，然后进入安装界面，等待........</p><h3 id="安装界面步骤">安装界面步骤：</h3><h2 id="选择语言">1.选择语言</h2><ol type="1"><li>选择简体中文并勾选协议：</li></ol><figure><img src="/2023/09/09/deepin%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85/image-20230906190813137.png" alt="image-20230906190813137"><figcaption aria-hidden="true">image-20230906190813137</figcaption></figure><p>点击下一步，再点击下一步</p><h2 id="硬盘分区">2.硬盘分区：</h2><p><strong>选择手动安装</strong>：</p><ul><li>点击右边的一个圆圈</li></ul><figure><img src="/2023/09/09/deepin%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85/image-20230906191008427.png" alt="image-20230906191008427"><figcaption aria-hidden="true">image-20230906191008427</figcaption></figure><h3 id="设置根目录分区">2.1 设置根目录分区</h3><ul><li>挂载点先选择根目录<code>/</code>，大小分配最小为20GB，多多益善，根目录分配的空间主要用来安装系统文件：</li></ul><figure><img src="/2023/09/09/deepin%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85/image-20230906191256626.png" alt="image-20230906191256626"><figcaption aria-hidden="true">image-20230906191256626</figcaption></figure><p>点击新建</p><h3 id="设置home目录分区">2.2 设置home目录分区</h3><ul><li>重述上述步骤，为home目录建立分区：</li></ul><figure><img src="/2023/09/09/deepin%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85/image-20230906191439055.png" alt="image-20230906191439055"><figcaption aria-hidden="true">image-20230906191439055</figcaption></figure><h3 id="设置swap分区">2.3 设置swap分区</h3><ul><li>再次点击可用空间右边的圆圈建立swap分区：<ul><li>文件系统选择交换分区</li><li>空间的分配按照主机内存，若主机内存为8GB，交换分区的大小可设为8GB，若主机内存为16GB，交换分区大小可以设置为8GB或16GB，具体交换分区的作用可自行百度。</li></ul></li></ul><p><strong>这里我是先分配的home目录的空间大小，后分配的swap分区的大小，便将剩余的空间全部分配给了swap分区，自行操作的话建议先设置swap分区大小，在设置根目录和home目录的空间大小。</strong></p><figure><img src="/2023/09/09/deepin%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85/image-20230906191810534.png" alt="image-20230906191810534"><figcaption aria-hidden="true">image-20230906191810534</figcaption></figure><p>至此硬盘的分区已经完成，单击下一步。</p><figure><img src="/2023/09/09/deepin%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85/image-20230906192107718.png" alt="image-20230906192107718"><figcaption aria-hidden="true">image-20230906192107718</figcaption></figure><h2 id="安装">3.安装</h2><figure><img src="/2023/09/09/deepin%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85/image-20230906192554993.png" alt="image-20230906192554993"><figcaption aria-hidden="true">image-20230906192554993</figcaption></figure><p>等待.......</p><p>安装完成之后会出现这种界面：</p><figure><img src="/2023/09/09/deepin%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85/image-20230906192632774.png" alt="image-20230906192632774"><figcaption aria-hidden="true">image-20230906192632774</figcaption></figure><p>系统提示拔出安装介质，这里我们选择的是ISO文件，且visualbox正在使用ISO文件，故此时可将虚拟机强制退出，并将deepin的ISO文件放入回收站。否则会循环引导安装。</p><h2 id="配置用户信息">4. 配置用户信息</h2><p>重新打开虚拟机：</p><figure><img src="/2023/09/09/deepin%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85/image-20230906193254731.png" alt="image-20230906193254731"><figcaption aria-hidden="true">image-20230906193254731</figcaption></figure><p>默认第一个选项会立即加载。</p><h3 id="选择语言-1">4.1 选择语言</h3><ul><li>选择简体中文并勾选协议</li></ul><figure><img src="/2023/09/09/deepin%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85/image-20230906193333397.png" alt="image-20230906193333397"><figcaption aria-hidden="true">image-20230906193333397</figcaption></figure><h3 id="选择时区">4.2 选择时区</h3><ul><li>默认北京即可</li></ul><figure><img src="/2023/09/09/deepin%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85/image-20230906193352753.png" alt="image-20230906193352753"><figcaption aria-hidden="true">image-20230906193352753</figcaption></figure><h3 id="创建账户">4.3 创建账户</h3><ul><li>用户名设为英文</li><li>计算机名设为英文(默认用户名+PC，可自行修改)</li><li>密码设置</li><li>重新输入密码</li></ul><figure><img src="/2023/09/09/deepin%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85/image-20230906193424078.png" alt="image-20230906193424078"><figcaption aria-hidden="true">image-20230906193424078</figcaption></figure><h3 id="等待优化系统配置">4.4 等待优化系统配置</h3><ul><li>等待就好了</li></ul><figure><img src="/2023/09/09/deepin%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85/image-20230906193439814.png" alt="image-20230906193439814"><figcaption aria-hidden="true">image-20230906193439814</figcaption></figure><p>等待优化完成之后便可见到：</p><figure><img src="/2023/09/09/deepin%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85/image-20230906193811631.png" alt="image-20230906193811631"><figcaption aria-hidden="true">image-20230906193811631</figcaption></figure><p>输入密码后选择普通模式：</p><figure><img src="/2023/09/09/deepin%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85/image-20230906193913970.png" alt="image-20230906193913970"><figcaption aria-hidden="true">image-20230906193913970</figcaption></figure><p>然后就大功告成啦！</p><h2 id="tips">tips</h2><ul><li>虚拟机的试图可以在<code>visualbox</code>中自行修改</li><li>进入虚拟机后可以在系统中修改<code>deepin</code>操作系统的分辨率及刷新率</li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;虚拟机安装&quot;&gt;虚拟机安装&lt;/h1&gt;
&lt;p&gt;本文演示虚拟机中安装&lt;code&gt;deepin&lt;/code&gt;操作系统，由于windows是闭源的，故不再演示，有兴趣的可以自行在B站找教程。Ubuntu与此类似，可在B站找最新的教程观看。&lt;/p&gt;
&lt;h2 id=&quot;准备环境&quot;&gt;准备环境&lt;/h2&gt;
&lt;p&gt;下载地址均选择清华大学开源镜像站镜像站&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;visualbox&lt;/code&gt;：&lt;a href=&quot;https://mirrors.tuna.tsinghua.edu.cn/virtualbox/virtualbox-Win-latest.exe&quot;&gt;点击下载&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;需要注意的是，有的电脑没有&lt;code&gt;msvc&lt;/code&gt;环境，会出现安装报错的情况，这里需要安装&lt;code&gt;visual C++&lt;/code&gt;环境：&lt;a href=&quot;https://aka.ms/vs/17/release/vc_redist.x64.exe&quot;&gt;点击下载&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;deepin&lt;/code&gt;：&lt;a href=&quot;https://mirrors.tuna.tsinghua.edu.cn/deepin-cd/20.6/deepin-desktop-community-20.6-amd64.iso&quot;&gt;点击下载&lt;/a&gt;
，这里下载的是ISO镜像文件。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Linux" scheme="http://lgq007.github.io/categories/Linux/"/>
    
    
    <category term="Linux" scheme="http://lgq007.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>数据结构基础</title>
    <link href="http://lgq007.github.io/2023/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/"/>
    <id>http://lgq007.github.io/2023/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/</id>
    <published>2023-09-09T01:13:54.000Z</published>
    <updated>2023-09-09T06:38:35.966Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据结构基础">数据结构基础</h1><h2 id="二维数组">二维数组</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DataType arr[nums][nums];</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> board[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line"><span class="comment">//二维数组，第一维度有10个成员，第二维度有10个成员</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> c[<span class="number">4</span>][<span class="number">5</span>][<span class="number">6</span>];</span><br><span class="line"><span class="comment">//三维数组</span></span><br></pre></td></tr></table></figure><p>引用二维数组成员时要使用两个方括号并指定两个维度：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">board[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">13</span>;</span><br><span class="line">board[<span class="number">9</span>][<span class="number">9</span>] = <span class="number">13</span>;</span><br></pre></td></tr></table></figure><p>注意，<code>board[0][0]</code>不能写成<code>board[0, 0]</code>，因为<code>0, 0</code>是一个逗号表达式，返回第二个值，所以<code>board[0, 0]</code>等同于<code>board[0]</code>。</p><ol type="1"><li>二维数组可以使用大括号一次性对所有成员赋值：</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">2</span>][<span class="number">5</span>] = &#123;</span><br><span class="line">    &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;,</span><br><span class="line">    &#123;<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面示例中，<code>a</code>是一个二维数组，这种赋值写法相当于将第一维的每个成员写成一个数组。==这种写法不用为每个成员都赋值，缺少的成员会自动设置为<code>0</code>。==</p><ol start="2" type="1"><li>二维数组指定位置初始化赋值：</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">2</span>][<span class="number">2</span>] = &#123;[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>, [<span class="number">1</span>][<span class="number">1</span>] = <span class="number">2</span>&#125;;</span><br></pre></td></tr></table></figure><p>上面示例中，指定了<code>[0][0]</code>和<code>[1][1]</code>位置的值，其他位置就自动设为<code>0</code>。</p><p>==不管数组有多少维度，在内存里面都是线性存储，<code>a[0][0]</code>的后面是<code>a[0][1]</code>，<code>a[0][1]</code>的后面是<code>a[1][0]</code>，以此类推。因此，多维数组也可以使用单层大括号赋值，下面的语句与上面的赋值语句是完全等同的。==</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">2</span>][<span class="number">2</span>] = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>&#125;;</span><br></pre></td></tr></table></figure><h2 id="数组的地址">数组的地址</h2><ul><li>数组是一连串连续储存的同类型值，只要获得起始地址（首个成员的内存地址），就能推算出其他成员的值</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">5</span>] = &#123;<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>, <span class="number">44</span>, <span class="number">55</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>* p;</span><br><span class="line"></span><br><span class="line">p = &amp;a[<span class="number">0</span>];  <span class="comment">//获取数组首地址</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *p);  <span class="comment">// Prints &quot;11&quot;</span></span><br></pre></td></tr></table></figure><p>由于数组的起始地址是常用操作，<code>&amp;array[0]</code>的写法有点麻烦，为了便利写法，==使数组名等同于起始地址==，也就是说，数组名就是指向第一个成员（<code>array[0]</code>）的指针。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">5</span>] = &#123;<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>, <span class="number">44</span>, <span class="number">55</span>&#125;;</span><br><span class="line"><span class="type">int</span>* p = &amp;a[<span class="number">0</span>];</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="type">int</span>* p = a;</span><br></pre></td></tr></table></figure><ul><li>将数组作为参数传入函数中时，传入数组名就等同于传入一个指针变量。在函数内部，就可以通过这个指针获取整个数组</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> len)</span>;</span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> len)</span>;</span><br></pre></td></tr></table></figure><p>上述中<code>int arr[]</code>和<code>int* arr</code>是等价的</p><h2 id="二维数组中指针的使用">二维数组中指针的使用</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">4</span>][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//取出a[0][0]的值</span></span><br><span class="line">*(a[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">//等同于</span></span><br><span class="line">**a;</span><br></pre></td></tr></table></figure><p>上面示例中，由于<code>a[0]</code>本身是一个指针，指向第二维数组的第一个成员<code>a[0][0]</code>。所以，<code>*(a[0])</code>取出的是<code>a[0][0]</code>的值。至于<code>**a</code>，就是对<code>a</code>进行两次<code>*</code>运算，第一次取出的是<code>a[0]</code>，第二次取出的是<code>a[0][0]</code>。同理，二维数组的<code>&amp;a[0][0]</code>等同于<code>*a</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">4</span>][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//指向arr[1]</span></span><br><span class="line">arr + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//指向arr[0][1]</span></span><br><span class="line">arr[<span class="number">0</span>] + <span class="number">1</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面示例中，<code>arr</code>是一个二维数组，<code>arr + 1</code>是将指针移动到第一维数组的下一个成员，即<code>arr[1]</code>。由于每个第一维的成员，本身都包含另一个数组，即<code>arr[0]</code>是一个指向第二维数组的指针，所以<code>arr[0] + 1</code>的含义是将指针移动到第二维数组的下一个成员，即<code>arr[0][1]</code>。</p><h3 id="指向二维数组的指针">指向二维数组的指针</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">3</span>][<span class="number">4</span>] = &#123;</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;,</span><br><span class="line">    &#123;<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;,</span><br><span class="line">    &#123;<span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>&#125;</span><br><span class="line">&#125;;  <span class="comment">//声明并初始化二维数组</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> (*ptr)[<span class="number">4</span>];   <span class="comment">//声明一个指向包含四个整数的一维数组的指针</span></span><br><span class="line"><span class="comment">//这里根据优先级关系，不能写为 int* ptr[4]</span></span><br><span class="line"></span><br><span class="line">ptr = arr; <span class="comment">//将指针指向二维数组的首行</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> element = (*ptr)[<span class="number">2</span>]; <span class="comment">//指向第一行的第三个元素(arr[0][3])</span></span><br><span class="line"></span><br><span class="line">ptr++; <span class="comment">//移动指针到下一行</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> element = (*ptr)[<span class="number">1</span>]; <span class="comment">//指向第二行的第二个元素</span></span><br></pre></td></tr></table></figure><h2 id="二维数组做函数参数">二维数组做函数参数</h2><h3 id="已知数组维度">已知数组维度</h3><p>已知数组维度，这里假设二维数组的列数为4</p><p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">myFunction</span><span class="params">(<span class="type">int</span> arr[][<span class="number">4</span>], <span class="type">int</span> rows)</span> &#123;</span><br><span class="line">    <span class="comment">// 函数体中处理二维数组</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">myFunction</span><span class="params">(<span class="type">int</span> (*arr)[<span class="number">4</span>], <span class="type">int</span> rows)</span>&#123;</span><br><span class="line">    <span class="comment">//处理二维数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="不知数组维度">不知数组维度</h3><p>使用动态分配内存：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">myFunction</span><span class="params">(<span class="type">int</span> **arr, <span class="type">int</span> rows, <span class="type">int</span> cols)</span> &#123;</span><br><span class="line">    <span class="comment">// 函数体中处理二维数组</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">allocateMatrix</span><span class="params">(<span class="type">int</span> ***arr, <span class="type">int</span> rows, <span class="type">int</span> cols)</span> &#123;</span><br><span class="line">    <span class="comment">// 分配内存以存储指针数组</span></span><br><span class="line">    *arr = (<span class="type">int</span> **)<span class="built_in">malloc</span>(rows * <span class="keyword">sizeof</span>(<span class="type">int</span> *));</span><br><span class="line">    <span class="keyword">if</span> (*arr == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;内存分配失败\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配内存以存储每行的整数数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">        (*arr)[i] = (<span class="type">int</span> *)<span class="built_in">malloc</span>(cols * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">        <span class="keyword">if</span> ((*arr)[i] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;内存分配失败\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">deallocateMatrix</span><span class="params">(<span class="type">int</span> **arr, <span class="type">int</span> rows)</span> &#123;</span><br><span class="line">    <span class="comment">// 释放每行的整数数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">        <span class="built_in">free</span>(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放指针数组</span></span><br><span class="line">    <span class="built_in">free</span>(arr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">myFunction</span><span class="params">(<span class="type">int</span> **arr, <span class="type">int</span> rows, <span class="type">int</span> cols)</span> &#123;</span><br><span class="line">    <span class="comment">// 在这里处理二维数组</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放内存</span></span><br><span class="line">    deallocateMatrix(arr, rows);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> rows = <span class="number">3</span>;</span><br><span class="line">    <span class="type">int</span> cols = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> **matrix;</span><br><span class="line">    allocateMatrix(&amp;matrix, rows, cols);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化二维数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; cols; j++) &#123;</span><br><span class="line">            matrix[i][j] = i * cols + j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用函数处理二维数组</span></span><br><span class="line">    myFunction(matrix, rows, cols);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//谨慎使用</span></span><br></pre></td></tr></table></figure><h1 id="内存管理">内存管理</h1><p>C语言中内存管理主要分为两部分：</p><ol type="1"><li>系统管理的内存，主要是函数内部的变量（局部变量），函数运行时写入内存内，运输结束后自动从内存中销毁。这边变量的存储区域称为“栈 ”（stack）。</li><li>用户管理的内存，主要是函数内部的全局变量，这些变量需要用户手动从内存释放，如果忘记释放会一直占用内存直至程序退出，这种情况称为“内存泄漏 ”（memory leak）。这些变量所在的区域被称为“ 堆 ”（heap）。</li></ol><h2 id="void-指针">void 指针</h2><ul><li><p>每一块内存都有地址，通过指针变量可以获取指定地址的内存块。</p></li><li><p>指针变量必须有类型，否则编译器无法知道，如何解读内存块保存的二进制数据。但是，向系统请求内存的时候，有时不确定会有什么样的数据写入内存，需要先获得内存块，稍后再确定写入的数据类型。</p></li></ul><p>==为了满足这种需求，C 语言提供了一种不定类型的指针，叫做 void指针。它只有内存块的地址信息，没有类型信息，等到使用该块内存的时候，再向编译器补充说明，里面的数据类型是什么。==</p><p>==另一方面，void指针等同于无类型指针，可以指向任意类型的数据，但是不能解读数据。void指针与其他所有类型指针之间是互相转换关系，任一类型的指针都可以转为 void指针，而 void 指针也可以转为任一类型的指针。==</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="type">void</span>* p = &amp;x; <span class="comment">// 整数指针转为 void 指针</span></span><br><span class="line"><span class="type">int</span>* q = p; <span class="comment">// void 指针转为整数指针</span></span><br></pre></td></tr></table></figure><p><code>&amp;x</code>是一个整数指针，<code>p</code>是 void指针，赋值时<code>&amp;x</code>的地址会自动解释为 void类型。同样的，<code>p</code>再赋值给整数指针<code>q</code>时，<code>p</code>的地址会自动解释为整数指针。</p><p>注意，由于不知道 void指针指向什么类型的值，所以不能用<code>*</code>运算符取出它指向的值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> a = <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line"><span class="type">void</span>* p = &amp;a;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>, *p); <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><p>上面示例中，<code>p</code>是一个 void指针，所以这时无法用<code>*p</code>取出指针指向的值。</p><p>void 指针的重要之处在于，很多内存相关函数的返回值就是 void指针，只给出内存块的地址信息，所以放在最前面进行介绍。</p><h2 id="malloc">malloc()</h2><p><code>malloc()</code>函数用于分配内存，该函数向系统要求一段内存，系统就在“堆”里面分配一段连续的内存块给它。它的原型定义在头文件<code>stdlib.h</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>* <span class="title function_">malloc</span><span class="params">(<span class="type">size_t</span> size)</span></span><br></pre></td></tr></table></figure><p>接受一个非负整数作为参数，表示所要分配的内存字节数，==返回一个 void指针==，指向分配好的内存块。</p><p><strong>这是非常合理的，因为<code>malloc()</code>函数不知道，将要存储在该块内存的数据是什么类型，所以只能返回一个无类型的void 指针。</strong></p><p><strong>可以使用<code>malloc()</code>为任意类型的数据分配内存，常见的做法是先使用<code>sizeof()</code>函数，算出某种数据类型所需的字节长度，然后再将这个长度传给<code>malloc()</code>。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* p = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">*p = <span class="number">12</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *p); <span class="comment">// 12</span></span><br></pre></td></tr></table></figure><p>上面示例中，先为整数类型分配一段内存，然后将整数<code>12</code>放入这段内存里面。这个例子其实不需要使用<code>malloc()</code>，因为C 语言会自动为整数（本例是<code>12</code>）提供内存。</p><p>有时候为了增加代码的可读性，可以对<code>malloc()</code>返回的指针进行一次强制类型转换。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* p = (<span class="type">int</span>*) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br></pre></td></tr></table></figure><p>上面代码将<code>malloc()</code>返回的 void指针，强制转换成了整数指针。</p><p>由于<code>sizeof()</code>的参数可以是变量，所以上面的例子也可以写成下面这样。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* p = (<span class="type">int</span>*) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*p));</span><br></pre></td></tr></table></figure><p><code>malloc()</code>分配内存有可能分配失败，这时返回常量 NULL。Null的值为0，是一个无法读写的内存地址，可以理解成一个不指向任何地方的指针。它在包括<code>stdlib.h</code>等多个头文件里面都有定义，所以只要可以使用<code>malloc()</code>，就可以使用<code>NULL</code>。由于存在分配失败的可能，所以最好在使用<code>malloc()</code>之后检查一下，是否分配成功。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* p = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"><span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;  </span><br><span class="line">    <span class="comment">// 内存分配失败</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"><span class="keyword">if</span> (!p) &#123;  <span class="comment">//...&#125;</span></span><br></pre></td></tr></table></figure><p>上面示例中，通过判断返回的指针<code>p</code>是否为<code>NULL</code>，确定<code>malloc()</code>是否分配成功。</p><p><strong><code>malloc()</code>最常用的场合，就是为数组和自定义数据结构分配内存。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* p = (<span class="type">int</span>*) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * <span class="number">10</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)  </span><br><span class="line">    p[i] = i * <span class="number">5</span>;</span><br></pre></td></tr></table></figure><p>上面示例中，<code>p</code>是一个整数指针，指向一段可以放置10个整数的内存，所以可以用作数组。</p><p><code>malloc()</code>用来创建数组，有一个好处，就是它可以创建动态数组，即根据成员数量的不同，而创建长度不同的数组。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* p = (<span class="type">int</span>*) <span class="built_in">malloc</span>(n * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br></pre></td></tr></table></figure><p>上面示例中，<code>malloc()</code>可以根据变量<code>n</code>的不同，动态为数组分配不同的大小。</p><p><strong>注意，<code>malloc()</code>不会对所分配的内存进行初始化，里面还保存着原来的值。如果没有初始化，就使用这段内存，可能从里面读到以前的值。程序员要自己负责初始化，比如，字符串初始化可以使用<code>strcpy()</code>函数。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* p = <span class="built_in">malloc</span>(<span class="number">4</span>);</span><br><span class="line"><span class="built_in">strcpy</span>(p, <span class="string">&quot;abc&quot;</span>);</span><br><span class="line"><span class="comment">// orp = &quot;abc&quot;;</span></span><br></pre></td></tr></table></figure><p>上面示例中，字符指针<code>p</code>指向一段4个字节的内存，<code>strcpy()</code>将字符串“abc”拷贝放入这段内存，完成了这段内存的初始化。</p><h2 id="free">free()</h2><p><code>free()</code>用于释放<code>malloc()</code>函数分配的内存，将这块内存还给系统以便重新使用，否则这个内存块会一直占用到程序运行结束。该函数的原型定义在头文件<code>stdlib.h</code>里面。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">free</span><span class="params">(<span class="type">void</span>* block)</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>free()</code>的参数是<code>malloc()</code>返回的内存地址。下面就是用法实例。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* p = (<span class="type">int</span>*) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>));*p = <span class="number">12</span>;</span><br><span class="line"><span class="built_in">free</span>(p);</span><br></pre></td></tr></table></figure><p>注意，分配的内存块一旦释放，就不应该再次操作已经释放的地址，也不应该再次使用<code>free()</code>对该地址释放第二次。</p><p>一个很常见的错误是，在函数内部分配了内存，但是函数调用结束时，没有使用<code>free()</code>释放内存。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">gobble</span><span class="params">(<span class="type">double</span> arr[], <span class="type">int</span> n)</span> &#123;  </span><br><span class="line">    <span class="type">double</span>* temp = (<span class="type">double</span>*) <span class="built_in">malloc</span>(n * <span class="keyword">sizeof</span>(<span class="type">double</span>));  </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面示例中，函数<code>gobble()</code>内部分配了内存，但是没有写<code>free(temp)</code>。这会造成函数运行结束后，占用的内存块依然保留，如果多次调用<code>gobble()</code>，就会留下多个内存块。并且，由于指针<code>temp</code>已经消失了，也无法访问这些内存块，再次使用。</p><h2 id="calloc">calloc()</h2><p><code>calloc()</code>函数的作用与<code>malloc()</code>相似，也是分配内存块。该函数的原型定义在头文件<code>stdlib.h</code>。</p><p>两者的区别主要有两点：</p><p><strong>（1）<code>calloc()</code>接受两个参数，第一个参数是某种数据类型的值的数量，第二个是该数据类型的单位字节长度。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>* <span class="title function_">calloc</span><span class="params">(<span class="type">size_t</span> n, <span class="type">size_t</span> size)</span>;</span><br></pre></td></tr></table></figure><p>==<code>calloc()</code>的返回值也是一个 void 指针==。分配失败时，返回NULL。</p><p><strong>（2）<code>calloc()</code>会将所分配的内存全部初始化为<code>0</code>。<code>malloc()</code>不会对内存进行初始化，如果想要初始化为<code>0</code>，还要额外调用<code>memset()</code>函数。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* p = <span class="built_in">calloc</span>(<span class="number">10</span>, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="type">int</span>* p = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * <span class="number">10</span>);</span><br><span class="line"><span class="built_in">memset</span>(p, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="type">int</span>) * <span class="number">10</span>);</span><br></pre></td></tr></table></figure><p>上面示例中，<code>calloc()</code>相当于<code>malloc() + memset()</code>。</p><p><code>calloc()</code>分配的内存块，也要使用<code>free()</code>释放。</p><h2 id="realloc">realloc()</h2><p><strong><code>realloc()</code>函数用于修改已经分配的内存块的大小，可以放大也可以缩小，返回一个指向新的内存块的指针。如果分配不成功，返回NULL。该函数的原型定义在头文件<code>stdlib.h</code>。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>* <span class="title function_">realloc</span><span class="params">(<span class="type">void</span>* block, <span class="type">size_t</span> size)</span></span><br></pre></td></tr></table></figure><p>它接受两个参数。</p><ul><li><code>block</code>：已经分配好的内存块指针（由<code>malloc()</code>或<code>calloc()</code>或<code>realloc()</code>产生）。</li><li><code>size</code>：该内存块的新大小，单位为字节。</li></ul><p><code>realloc()</code>可能返回一个全新的地址（数据也会自动复制过去），也可能返回跟原来一样的地址。<code>realloc()</code>优先在原有内存块上进行缩减，尽量不移动数据，所以通常是返回原先的地址。如果新内存块小于原来的大小，则丢弃超出的部分；如果大于原来的大小，则不对新增的部分进行初始化（程序员可以自动调用<code>memset()</code>）。</p><p>下面是一个例子，<code>b</code>是数组指针，<code>realloc()</code>动态调整它的大小。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* b;</span><br><span class="line">b = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * <span class="number">10</span>);</span><br><span class="line">b = <span class="built_in">realloc</span>(b, <span class="keyword">sizeof</span>(<span class="type">int</span>) * <span class="number">2000</span>);</span><br></pre></td></tr></table></figure><p>上面示例中，指针<code>b</code>原来指向10个成员的整数数组，使用<code>realloc()</code>调整为2000个成员的数组。这就是手动分配数组内存的好处，可以在运行时随时调整数组的长度。</p><p><code>realloc()</code>的第一个参数可以是NULL，这时就相当于新建一个指针。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* p = <span class="built_in">realloc</span>(<span class="literal">NULL</span>, <span class="number">3490</span>);</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="type">char</span>* p = <span class="built_in">malloc</span>(<span class="number">3490</span>);</span><br></pre></td></tr></table></figure><p>如果<code>realloc()</code>的第二个参数是<code>0</code>，就会释放掉内存块。</p><p>由于有分配失败的可能，所以调用<code>realloc()</code>以后，最好检查一下它的返回值是否为NULL。分配失败时，原有内存块中的数据不会发生改变。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span>* new_p = <span class="built_in">realloc</span>(p, <span class="keyword">sizeof</span>(*p * <span class="number">40</span>));</span><br><span class="line"><span class="keyword">if</span> (new_p == <span class="literal">NULL</span>) &#123;  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Error reallocing\n&quot;</span>);  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，<code>realloc()</code>不会对内存块进行初始化。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;数据结构基础&quot;&gt;数据结构基础&lt;/h1&gt;
&lt;h2 id=&quot;二维数组&quot;&gt;二维数组&lt;/h2&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;DataType arr[nums][nums];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; board[&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;][&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//二维数组，第一维度有10个成员，第二维度有10个成员&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; c[&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;][&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;][&lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//三维数组&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;引用二维数组成员时要使用两个方括号并指定两个维度：&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构" scheme="http://lgq007.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="C++" scheme="http://lgq007.github.io/tags/C/"/>
    
    <category term="C" scheme="http://lgq007.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++入门-3</title>
    <link href="http://lgq007.github.io/2023/09/01/C++%E5%85%A5%E9%97%A8-3/"/>
    <id>http://lgq007.github.io/2023/09/01/C++%E5%85%A5%E9%97%A8-3/</id>
    <published>2023-09-01T01:13:54.000Z</published>
    <updated>2023-09-16T06:10:23.651Z</updated>
    
    <content type="html"><![CDATA[<h1 id="表达式基础">表达式基础</h1><blockquote><p>表达式是有一个或多个运算对象(operand)所组成的，对表达式求值将得到的是一个结果(result)。字面值和变量是最简单的表达式(expression)，结果是字面值和变量的值。把一个运算符(operator)和一个或者多个运算对象组合起来可以生成复杂的表达式</p></blockquote><ul><li>一元运算符(unary operator)<ul><li>作用与一个运算对象</li><li>如取地址符<code>&amp;</code>和解引用符<code>*</code></li></ul></li><li>二元运算符(binary operator)<ul><li>作用于两个运算对象</li><li>如相等运算符<code>==</code>，乘法运算符<code>*</code></li></ul></li><li>三元运算符<ul><li>作用于三个运算对象</li></ul></li><li>函数也是一种特殊的运算符<ul><li>对运算对象数量没有限制</li></ul></li><li>一些符号既能做一元运算符，也能做二元运算符<ul><li>由上下文决定</li><li>如<code>*</code>，可用做解引用和乘法</li></ul></li></ul><h2 id="组合运算符和运算对象">组合运算符和运算对象</h2><p>对于含有多个运算符的复杂表达式，要理解：</p><ol type="1"><li>运算符的优先级(precedence)</li><li>运算符的结合律(associativity)</li><li>运算对象的求值顺序(order of evaluation)</li></ol><h2 id="运算对象转换">运算对象转换</h2><p>表达式求值的过程中，运算对象常由一种类型转换成另一种类型。如二元运算符要求两个运算对象类型相同，若不同，转换成同一种类型。</p><p>类型转换的规则复杂，但大多数合乎情理容易理解：</p><ol type="1"><li>整数转浮点数，浮点数转整数</li><li>指针不能转浮点数</li><li>小整数类型(<code>bool</code>，<code>char</code>，<code>short</code>) 提升(promoted) 成较大整数类型（主要是<code>int</code>）</li></ol><h2 id="重载运算符">重载运算符</h2><p>C++语言定义了运算符作用于内置类型和复合类型的运算对象时所执行的操作</p><ul><li>当运算符作用在类类型的运算对象时，用户可以自行定义其含义。</li><li>为已存在的运算符赋予另外一层含义，称为<strong>重载运算符</strong>（overloadedoperator）<ul><li>如IO库中的&gt;&gt;，&lt;&lt;，string对象，vector对象，迭代器所使用的运算符。</li></ul></li></ul><p>重载运算符可自定义运算对象类型和返回值，但无法改变运算对象个数，运算符优先级，结合律</p><h1 id="算术运算符">算术运算符</h1><ul><li>算术运算符（左结合律）</li></ul><table><thead><tr class="header"><th style="text-align: center;">运算符</th><th style="text-align: center;">功能</th><th style="text-align: center;">用法</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><code>+</code></td><td style="text-align: center;">一元正号</td><td style="text-align: center;">+ expr</td></tr><tr class="even"><td style="text-align: center;"><code>-</code></td><td style="text-align: center;">一元负号</td><td style="text-align: center;">- expr</td></tr><tr class="odd"><td style="text-align: center;"><code>*</code></td><td style="text-align: center;">乘法</td><td style="text-align: center;">expr*expr</td></tr><tr class="even"><td style="text-align: center;"><code>/</code></td><td style="text-align: center;">除法</td><td style="text-align: center;">expr/expr</td></tr><tr class="odd"><td style="text-align: center;"><code>%</code></td><td style="text-align: center;">求余</td><td style="text-align: center;">expr%expr</td></tr><tr class="even"><td style="text-align: center;"><code>+</code></td><td style="text-align: center;">加法</td><td style="text-align: center;">expr+expr</td></tr><tr class="odd"><td style="text-align: center;"><code>-</code></td><td style="text-align: center;">减法</td><td style="text-align: center;">expr-expr</td></tr></tbody></table><ul><li><p>优先级：一元运算符 先乘除，再加减</p></li><li><p>算数运算符可作用于任意算术类型以及任意能转换成算术类型的类型</p></li><li><p>运算对象和求值结果都是右值</p></li><li><p><code>+</code>,<code>-</code>可作用于指针，算数值</p><ul><li><p>+-指针或+-算数值，返回运算对象值的一个（提升后）的副本</p></li><li><p>bool类型不应该参与计算</p></li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//exp3.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> i = <span class="number">1024</span>;</span><br><span class="line"><span class="type">int</span> k = -i; <span class="comment">//k is -1024</span></span><br><span class="line"><span class="type">bool</span> b = <span class="literal">true</span>;</span><br><span class="line"><span class="type">bool</span> b2 = -b; <span class="comment">// b2 is true!</span></span><br><span class="line"><span class="comment">//bool类型不应该参与计算</span></span><br><span class="line"><span class="comment">//b为true，提升为对应整数1，-b=-1</span></span><br><span class="line"><span class="comment">//b2=-1≠0，所以b2仍为true</span></span><br><span class="line">cout &lt;&lt; b &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; b2 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="溢出和其他算数运行异常">溢出和其他算数运行异常</h2><ul><li>算术表达式有可能产生未定义的结果<ul><li>数学性质，如果除数是0</li><li>计算机特点，如溢出，计算结果超出该类型所能表示的范围</li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//overflow.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">short</span> short_value = <span class="number">32767</span>; <span class="comment">// max value if shorts are 16 bits</span></span><br><span class="line">short_value += <span class="number">1</span>; <span class="comment">// this calculation overflows</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;short_value: &quot;</span> &lt;&lt; short_value &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//short_value: -32768</span></span><br></pre></td></tr></table></figure><ul><li>作用算术类型对象时，+-*/含义分别是加减乘除<ul><li>整数相除还是整数，商的小数部分直接 舍弃</li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//div.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// ival1 is 3; result is truncated; remainder is discarded</span></span><br><span class="line"><span class="type">int</span> ival1 = <span class="number">21</span> / <span class="number">6</span>;</span><br><span class="line"><span class="comment">// ival2 is 3; no remainder; result is an integral value</span></span><br><span class="line"><span class="type">int</span> ival2 = <span class="number">21</span> / <span class="number">7</span>;</span><br><span class="line">cout &lt;&lt; ival1 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; ival2 &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3 3</span></span><br></pre></td></tr></table></figure><ul><li>运算符%，取余、取模运算符<ul><li>参与计算两个整数相除所得的余数</li><li>参与取余的运算对象必须时整数类型</li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//exp4.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> ival = <span class="number">42</span>;</span><br><span class="line"><span class="type">double</span> dval = <span class="number">3.14</span>;</span><br><span class="line">cout &lt;&lt; ival % <span class="number">12</span> &lt;&lt; endl; <span class="comment">// 6</span></span><br><span class="line"><span class="comment">//ival % dval;// error</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//6</span></span><br></pre></td></tr></table></figure><ul><li>除法运算，两个运算对象符号相同则商为正（如果不为0），否则商为负<ul><li>早期版本允许负值的商向上或向下取整</li><li>C++ 11新标准规定商向0取整（即直接切除小数部分）</li></ul></li><li>取余运算，如果m和n是整数且n非0，则表达式(m/n)*n +m%n的求值结果与m相等。<ul><li>如果m%n不为0，结果符号与m相同</li><li>早期版本允许m%n符号匹配n的符号，商向负无穷一侧取整</li><li>C++ 11新标准，除了-m导致溢出的特殊情况，其他时候<ul><li>(-m)/n和m/(-n)都等于-(m/n)</li><li>m%(-n)等于m%n</li><li>(-m)%n等于-m%n</li></ul></li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//div2.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="number">21</span> % <span class="number">6</span> &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="number">21</span> / <span class="number">6</span> &lt;&lt; endl; <span class="comment">//3 3</span></span><br><span class="line">cout &lt;&lt; <span class="number">21</span> % <span class="number">7</span> &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="number">21</span> / <span class="number">7</span> &lt;&lt; endl; <span class="comment">//0 3</span></span><br><span class="line">cout &lt;&lt; <span class="number">-21</span> % <span class="number">-8</span> &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="number">-21</span> / <span class="number">-8</span> &lt;&lt; endl; <span class="comment">//-5 2</span></span><br><span class="line">cout &lt;&lt; <span class="number">21</span> % <span class="number">-5</span> &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="number">21</span> / <span class="number">-5</span> &lt;&lt; endl; <span class="comment">//1 -4</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="练习">练习</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//写出下列表达式的求值结果。</span></span><br><span class="line"><span class="number">-30</span> * <span class="number">3</span> + <span class="number">21</span> / <span class="number">5</span> <span class="comment">// -90 + 4 = -86</span></span><br><span class="line">- <span class="number">30</span> + <span class="number">3</span> * <span class="number">21</span> / <span class="number">5</span> <span class="comment">// -30 + 63/5 = -30 + 12 = -18</span></span><br><span class="line"><span class="number">30</span> / <span class="number">3</span> * <span class="number">21</span> % <span class="number">5</span> <span class="comment">// 10*21%5 = 210%5 = 0</span></span><br><span class="line">- <span class="number">30</span> / <span class="number">3</span> * <span class="number">21</span> % <span class="number">4</span> <span class="comment">// -10*21%4 = -210%4 = -2</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//溢出是何含义？写出三条将导致溢出的表达式。</span></span><br><span class="line"><span class="comment">//当计算的结果超出该类型所能表示的范围时就会产生溢出。</span></span><br><span class="line"><span class="type">short</span> v1 = <span class="number">32767</span>;</span><br><span class="line">+ +v1; <span class="comment">// -32768</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> v2 = <span class="number">0</span>;</span><br><span class="line">- -v2; <span class="comment">// 4294967295</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> v3 = <span class="number">65535</span>;</span><br><span class="line">+ +v3; <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//exp5.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="number">-30</span> * <span class="number">3</span> + <span class="number">21</span> / <span class="number">5</span> &lt;&lt; endl; <span class="comment">// -90+4 = -86</span></span><br><span class="line">cout &lt;&lt; <span class="number">-30</span> + <span class="number">3</span> * <span class="number">21</span> / <span class="number">5</span> &lt;&lt; endl; <span class="comment">// -30+63/5 = -30+12 = -18</span></span><br><span class="line">cout &lt;&lt; <span class="number">30</span> / <span class="number">3</span> * <span class="number">21</span> % <span class="number">5</span> &lt;&lt; endl; <span class="comment">// 10*21%5 = 210%5 = 0</span></span><br><span class="line">cout &lt;&lt; <span class="number">-30</span> / <span class="number">3</span> * <span class="number">21</span> % <span class="number">4</span> &lt;&lt; endl; <span class="comment">// -10*21%4 = -210%4 = -2</span></span><br><span class="line"><span class="type">short</span> v1 = <span class="number">32767</span>;</span><br><span class="line">cout &lt;&lt; ++v1 &lt;&lt; endl; <span class="comment">// -32768</span></span><br><span class="line"><span class="type">unsigned</span> v2 = <span class="number">0</span>;</span><br><span class="line">cout &lt;&lt; --v2 &lt;&lt; endl; <span class="comment">// 4294967295</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> v3 = <span class="number">65535</span>;</span><br><span class="line">cout &lt;&lt; ++v3 &lt;&lt; endl; <span class="comment">// 0</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="逻辑和关系运算符">逻辑和关系运算符</h1><table><thead><tr class="header"><th style="text-align: center;">结合律</th><th style="text-align: center;">运算符</th><th style="text-align: center;">功能</th><th style="text-align: center;">用法</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">右</td><td style="text-align: center;">！</td><td style="text-align: center;">逻辑非</td><td style="text-align: center;">!expr</td></tr><tr class="even"><td style="text-align: center;">左</td><td style="text-align: center;">&lt;</td><td style="text-align: center;">小于</td><td style="text-align: center;">expr&lt;expr</td></tr><tr class="odd"><td style="text-align: center;">左</td><td style="text-align: center;">&lt;=</td><td style="text-align: center;">小于等于</td><td style="text-align: center;">expr&lt;=expr</td></tr><tr class="even"><td style="text-align: center;">左</td><td style="text-align: center;">&gt;</td><td style="text-align: center;">大于</td><td style="text-align: center;">expr&gt;expr</td></tr><tr class="odd"><td style="text-align: center;">左</td><td style="text-align: center;">&gt;=</td><td style="text-align: center;">大于等于</td><td style="text-align: center;">expr&gt;=expr</td></tr><tr class="even"><td style="text-align: center;">左</td><td style="text-align: center;">==</td><td style="text-align: center;">相等</td><td style="text-align: center;">expr==expr</td></tr><tr class="odd"><td style="text-align: center;">左</td><td style="text-align: center;">!=</td><td style="text-align: center;">不相等</td><td style="text-align: center;">expr!=expr</td></tr><tr class="even"><td style="text-align: center;">左</td><td style="text-align: center;">&amp;&amp;</td><td style="text-align: center;">逻辑与</td><td style="text-align: center;">expr&amp;&amp;expr</td></tr><tr class="odd"><td style="text-align: center;">左</td><td style="text-align: center;">||</td><td style="text-align: center;">逻辑或</td><td style="text-align: center;">expr||expr</td></tr></tbody></table><h2 id="逻辑与和逻辑或运算符">逻辑与和逻辑或运算符</h2><ul><li><p>逻辑与&amp;&amp;</p><ul><li>当且仅当两个运算对象都为真时结果为真</li><li>当且仅当左侧运算对象为真才对右侧对象求值</li></ul></li><li><p>逻辑或||</p><ul><li>只要两个运算对象中的⼀个为真结果就为真</li><li>当且仅当左侧运算对象为假才对右侧对象求值</li></ul></li><li><p>都先求左侧运算对象的值，再求右侧运算对象的值当且仅当左侧运算对象无法确定确定表达式的结果时，才会计算右侧表达式的值。这种策略称为 <strong>短路求值</strong></p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//逻辑或运算符举例</span></span><br><span class="line"><span class="comment">//exp6.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"><span class="keyword">using</span> std::string;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">vector&lt;string&gt; text = &#123;<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;abc&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;efg.&quot;</span>, <span class="string">&quot;hi&quot;</span>&#125;;</span><br><span class="line"><span class="comment">//s是对常量的引用，元素既没有拷贝也不会改变</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; s : text) &#123;</span><br><span class="line">cout &lt;&lt; s ; <span class="comment">//输出当且元素</span></span><br><span class="line"><span class="comment">//遇到空字符串 或者以句号结束的字符串进行换行</span></span><br><span class="line"><span class="keyword">if</span> (s.<span class="built_in">empty</span>() || s[s.<span class="built_in">size</span>() - <span class="number">1</span>] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">//否则以空格隔开</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//abc abc</span></span><br><span class="line"><span class="comment">//efg.</span></span><br><span class="line"><span class="comment">//hi</span></span><br></pre></td></tr></table></figure><ul><li>小技巧，声明为引用类型可以避免对元素的拷贝，又因为不需要做读写操作，声明成对常量的引用</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span> &amp;s : text)&#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="逻辑非运算符">逻辑非运算符</h2><ul><li>逻辑非运算符！将运算对象的值取反后返回</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//exp7.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"><span class="keyword">using</span> std::string;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="comment">//输出vec的首个元素 如果有的话</span></span><br><span class="line"><span class="comment">//子表达式!vec.empty()，当empty()函数返回假时结果为真</span></span><br><span class="line"><span class="keyword">if</span> (!vec.<span class="built_in">empty</span>())</span><br><span class="line">cout &lt;&lt; vec[<span class="number">0</span>]; <span class="comment">//1</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="关系运算符">关系运算符</h2><ul><li>关系运算符比较运算对象的大小并返回布尔值</li><li>关系运算符满足左结合律</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//拿i&lt;j的布尔值和k比较</span></span><br><span class="line"><span class="keyword">if</span>(i &lt; j &lt; k)  <span class="comment">//若k大于1则为真</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//i&lt;j 且 j&lt;k 为真</span></span><br><span class="line"><span class="keyword">if</span>(i &lt; j &amp;&amp; j &lt; k)</span><br></pre></td></tr></table></figure><h2 id="相等性测试与布尔字面值">相等性测试与布尔字面值</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试算数对象或指针对象的真值</span></span><br><span class="line"><span class="keyword">if</span>(val)&#123;&#125;<span class="comment">//val不为0，条件为真</span></span><br><span class="line"><span class="keyword">if</span>(!val)&#123;&#125;<span class="comment">//val为0，条件为真</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//有时会写成</span></span><br><span class="line"><span class="keyword">if</span>(val==<span class="literal">true</span>)&#123;&#125;<span class="comment">//val等于1时 条件为真</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这种写法存在两个问题</span></span><br><span class="line"><span class="comment">- 写法长 不直接</span></span><br><span class="line"><span class="comment">- 如果val不是布尔值，则比较失去意义</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//如val不是布尔值，则true转为val的类型，代码等价于</span></span><br><span class="line"><span class="keyword">if</span>(val==<span class="number">1</span>)&#123;&#125;</span><br></pre></td></tr></table></figure><ul><li>进行比较运算时，除非比较对象是布尔值，否则不要把布尔字面值true和false作为运算对象</li></ul><h3 id="练习-1">练习</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//解释西面的if语句中条件部分的判断过程</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *cp = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"><span class="keyword">if</span>(cp &amp;&amp; *cp);</span><br><span class="line"></span><br><span class="line"><span class="comment">//首先判断cp,cp不是一个空指针，因此cp为真</span></span><br><span class="line"><span class="comment">//然后判断*cp，*cp的值是字符&quot;h&quot;，非0，所以最后为真</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//假设i,j,k是三个整数，说明表达式i != j &lt; k的含义：</span></span><br><span class="line"><span class="comment">//i != j &lt; k  &lt;==&gt; i != (j &lt; K)</span></span><br><span class="line"><span class="comment">//首先得到j &lt; k的结果由布尔值转换为数值1或0</span></span><br><span class="line"><span class="comment">//再与i比较，返回布尔值</span></span><br></pre></td></tr></table></figure><h1 id="赋值运算符">赋值运算符</h1><ul><li>赋值运算符的左侧运算对象必须是一个可修改的值</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, k = <span class="number">0</span>; <span class="comment">//初始化而非赋值</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> ci = i; <span class="comment">//初始化而非赋值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//下面赋值语句非法</span></span><br><span class="line"><span class="number">1024</span> = k; <span class="comment">//错误，字面值1024是右值</span></span><br><span class="line">i + j = k; <span class="comment">//错误，算数表达式是右值</span></span><br><span class="line">ci = k; <span class="comment">//错误，ci是常量（不可修改）左值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//赋值运算符左右类型不同，右侧将转换成左侧运算对象类型</span></span><br><span class="line">k = <span class="number">0</span>; <span class="comment">//k=0</span></span><br><span class="line">k = <span class="number">3.14</span>; <span class="comment">//k=3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//C++11允许花括号初始值列表作为赋值语句右侧运算对象</span></span><br><span class="line"><span class="comment">//C++11花括号初始值列表不能窄化转换</span></span><br><span class="line">k = &#123;<span class="number">3.14</span>&#125;; <span class="comment">//错误，窄化转化</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; vi; <span class="comment">//初始值为空</span></span><br><span class="line">vi = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;; <span class="comment">//十个元素 0-9</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//exp8.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"><span class="keyword">using</span> std::string;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, k = <span class="number">0</span>; <span class="comment">//初始化而非赋值</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> ci = i; <span class="comment">//初始化而非赋值</span></span><br><span class="line"><span class="comment">//1024 = k; //错误，字面值1024是右值</span></span><br><span class="line"><span class="comment">//i+j = k; //错误，算数表达式是右值</span></span><br><span class="line"><span class="comment">//ci = k; //错误，ci是常量（不可修改）左值</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//赋值运算符左右类型不同，右侧将转换成左侧运算对象类型</span></span><br><span class="line">k = <span class="number">0</span>; <span class="comment">//k=0</span></span><br><span class="line">cout &lt;&lt; k &lt;&lt; endl;</span><br><span class="line">k = <span class="number">3.14</span>; <span class="comment">//k=3</span></span><br><span class="line">cout &lt;&lt; k &lt;&lt; endl;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; vi; <span class="comment">//初始值为空</span></span><br><span class="line"><span class="comment">//k = &#123;3.14&#125;; //错误，窄化转化</span></span><br><span class="line">vi = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;; <span class="comment">//十个元素 0-9</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> a : vi) &#123;</span><br><span class="line">cout &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>赋值运算符满足右结合律</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ival,jval;</span><br><span class="line">ival = jval = <span class="number">0</span>;<span class="comment">//都被赋值为0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//多重赋值语句</span></span><br><span class="line"><span class="type">int</span> ival ,*pval;</span><br><span class="line">ival = pval = <span class="number">0</span>;<span class="comment">//error，不能把int赋给指针</span></span><br><span class="line"></span><br><span class="line">string s1,s2;</span><br><span class="line">s1 = s2 = <span class="string">&quot;ok&quot;</span>; <span class="comment">//字符串字面值&quot;ok&quot;转为string对象</span></span><br></pre></td></tr></table></figure><ul><li>赋值运算优先级比较低，低于关系运算符的优先级，赋值部分通常应该加上括号</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//繁琐写法 容易出错</span></span><br><span class="line"><span class="type">int</span> i = <span class="built_in">get_value</span>();<span class="comment">//得到一个值</span></span><br><span class="line"><span class="keyword">while</span> (i != <span class="number">42</span>) &#123;</span><br><span class="line"><span class="comment">//其它处理...</span></span><br><span class="line">i = <span class="built_in">get_value</span>();<span class="comment">//得到剩下的值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//更好的写法</span></span><br><span class="line"><span class="comment">// 更好的写法</span></span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">while</span> ((i = <span class="built_in">get_value</span>()) != <span class="number">42</span>) &#123;</span><br><span class="line"><span class="comment">//其它处理...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//不加括号含义变化</span></span><br></pre></td></tr></table></figure><ul><li>切勿混淆相等运算符和赋值运算符</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(i = j)<span class="comment">//j不为0，则真</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span>(i == j)<span class="comment">//判断i与j是否相等</span></span><br></pre></td></tr></table></figure><h2 id="复合赋值运算符">复合赋值运算符</h2><p>任何复合运算 <strong>a op= b &lt;==&gt; a = a op b</strong></p><ul><li>复合运算符只求值一次</li><li>普通运算符求值两次<ul><li>右边表达式求值</li><li>赋值</li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sum += val;</span><br><span class="line"></span><br><span class="line"><span class="comment">//+= -= /= %=  //算数运算符</span></span><br><span class="line"><span class="comment">//&lt;&lt;= &gt;&gt;= &amp;= ^= |= //位运算符</span></span><br></pre></td></tr></table></figure><h2 id="练习-2">练习</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在下述语句中，当赋值完成后 i 和 d 的值分别是多少？</span></span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="type">double</span> d;</span><br><span class="line">d = i = <span class="number">3.5</span>; <span class="comment">// i = 3, d = 3.0</span></span><br><span class="line">i = d = <span class="number">3.5</span>; <span class="comment">// d = 3.5, i = 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//执行下述 if 语句后将发生什么情况？</span></span><br><span class="line"><span class="keyword">if</span> (<span class="number">42</span> = i); <span class="comment">// 编译错误。赋值运算符左侧必须是一个可修改的左值。而字面值是右值。</span></span><br><span class="line"><span class="keyword">if</span> (i = <span class="number">42</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//下面的赋值是非法的，为什么？应该如何修改？</span></span><br><span class="line"><span class="type">double</span> dval;</span><br><span class="line"><span class="type">int</span> ival;</span><br><span class="line"><span class="type">int</span> *pi;</span><br><span class="line">dval = ival = pi = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//p是指针，不能赋值给int，应该改为：</span></span><br><span class="line">dval = ival = <span class="number">0</span>;</span><br><span class="line">pi = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//尽管下面的语句合法，但它们实际执行的行为可能和预期并不一样，为什么？应该如何修改？</span></span><br><span class="line"><span class="keyword">if</span> (p = <span class="built_in">getPtr</span>() != <span class="number">0</span>)</span><br><span class="line"><span class="keyword">if</span> (i = <span class="number">1024</span>)</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">if</span> ((p=<span class="built_in">getPtr</span>()) != <span class="number">0</span>)</span><br><span class="line"><span class="keyword">if</span> (i == <span class="number">1024</span>)</span><br></pre></td></tr></table></figure><h1 id="递增和递减运算符">递增和递减运算符</h1><ul><li>作用于左值运算对象</li><li>前置版本<ul><li>加减1，将改变后的对象作为求值结果</li><li>将对象本身作为左值返回</li></ul></li><li>后置版本<ul><li>加减1，求值结果是运算对象改变之前值的副本</li><li>将对象原始值的副本作为右值返回</li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>, j;</span><br><span class="line">j = ++i;<span class="comment">//j=1,i=1,先加后赋值,</span></span><br><span class="line">j = i++;<span class="comment">//j=1,i=2,先赋值后加</span></span><br><span class="line"><span class="comment">// 优先使用前置版本，后置多一步储存原始值。（除非需要变化前的值）</span></span><br></pre></td></tr></table></figure><h2 id="混用解引用和递增运算符">混用解引用和递增运算符</h2><ul><li>递增优先级较高，<strong><em>iter++ &lt;==&gt;</em>(iter++)</strong></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> iter = vi.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">while</span> (iter != vi.<span class="built_in">end</span>() &amp;&amp; *iter &gt;= <span class="number">0</span>)</span><br><span class="line">cout &lt;&lt; *iter++ &lt;&lt; endl; <span class="comment">// 输出当前值，指针向前移1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; *iter++ &lt;&lt; endl;</span><br><span class="line"><span class="comment">//比下面的等价语句更简洁、更少出错</span></span><br><span class="line">cout &lt;&lt; *iter &lt;&lt; endl;</span><br><span class="line">iter++;</span><br></pre></td></tr></table></figure><h2 id="运算对象可按任意顺序求值">运算对象可按任意顺序求值</h2><ul><li>递增和递减运算符会改变运算对象的值，不要在复合表达式里错用这两个运算符。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//该循环的行为未定义</span></span><br><span class="line"><span class="keyword">while</span> (beg != s.<span class="built_in">end</span>() &amp;&amp; !<span class="built_in">isspace</span>(*beg)) &#123;</span><br><span class="line">*beg = <span class="built_in">toupper</span>(*beg++);<span class="comment">//错误，该赋值语句未定义</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//赋值运算符两端都用到了beg，右侧改变beg的值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//所以赋值语句是未定义的。可能按照下面方式,或其它方式。</span></span><br><span class="line">*beg = <span class="built_in">toupper</span>(*beg); <span class="comment">//先求左侧的值</span></span><br><span class="line">*(beg + <span class="number">1</span>) = <span class="built_in">toupper</span>(*beg); <span class="comment">//先求右侧的值</span></span><br></pre></td></tr></table></figure><h2 id="练习-3">练习</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//假设ptr的类型是指向int的指针、vec的类型是vector&lt;int&gt;、ival的类型是int</span></span><br><span class="line"><span class="comment">//说明下面的表达式是何含义？如果有表达式不正确，为什么？应该如何修改？</span></span><br><span class="line">(a) ptr != <span class="number">0</span> &amp;&amp; *ptr++</span><br><span class="line">(b) ival++ &amp;&amp; <span class="built_in">ival</span></span><br><span class="line">(c) vec[ival++] &lt;= vec[ival]</span><br><span class="line">- (a) 判断ptr不是一个空指针，并且ptr当前指向的元素的值也为真，</span><br><span class="line">然后将ptr指向下一个元素</span><br><span class="line">- (b) 判断ival的值为真，并且(ival + <span class="number">1</span>)的值也为真</span><br><span class="line">- (c) 表达式有误。C++并没有规定&lt;=运算符两边的求值顺序，</span><br><span class="line">应该改为vec[ival] &lt;= vec[ival+<span class="number">1</span>]</span><br></pre></td></tr></table></figure><h1 id="成员访问运算符">成员访问运算符</h1><ul><li>点运算符，获取类对象的一个成员<ul><li>成员所属的对象是左值，那么结果是左值</li><li>成员所属的对象是右值，那么结果是右值</li></ul></li><li>箭头运算符，**ptr-&gt;mem &lt;==&gt; (*ptr).mem**<ul><li>.运算符优先级高于*，所以加括号</li><li>作用于一个指针类型的运算对象，结果是左值</li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">string s1 = <span class="string">&quot;a string&quot;</span>, *p = &amp;s1;</span><br><span class="line"><span class="keyword">auto</span> n = s1.<span class="built_in">size</span>();</span><br><span class="line">n = (*p).<span class="built_in">size</span>();</span><br><span class="line">n = p-&gt;<span class="built_in">size</span>(); <span class="comment">//等价 (*p).size</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//不加括号的话</span></span><br><span class="line">*p.<span class="built_in">size</span>(); <span class="comment">//p是一个指针，没有size成员</span></span><br></pre></td></tr></table></figure><h2 id="练习-4">练习</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//假设iter的类型是vector&lt;string&gt;::iterator, 说明下面的表达式是否合法。</span></span><br><span class="line"><span class="comment">//如果合法，表达式的含义是什么？如果不合法，错在何处？</span></span><br><span class="line">(a) *iter++;</span><br><span class="line">(b) (*iter)++;</span><br><span class="line">(c) *iter.<span class="built_in">empty</span>();</span><br><span class="line">(d) iter-&gt;<span class="built_in">empty</span>();</span><br><span class="line">(e) ++*iter;</span><br><span class="line">(f) iter++-&gt;<span class="built_in">empty</span>();</span><br><span class="line">- (a)合法。返回迭代器所指向的元素，然后迭代器递增。</span><br><span class="line">- (b)不合法。因为vector元素类型是string，没有++操作。</span><br><span class="line">- (c)不合法。这里应该加括号。</span><br><span class="line">- (d)合法。判断迭代器当前的元素是否为空。</span><br><span class="line">- (e)不合法。string类型没有++操作。</span><br><span class="line">- (f)合法。判断迭代器当前元素是否为空，然后迭代器递增。</span><br></pre></td></tr></table></figure><h1 id="条件运算符">条件运算符</h1><ul><li>条件运算符（?:）允许我们把简单的if-else逻辑嵌⼊到单个表达式中去，按照如下形式：<strong>cond?expr1: expr2</strong></li><li>两个表达式都是左值或能转换成同⼀种左值，运算结果是左值，否则运算结果是右值。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string finalgrade = (grade &lt; <span class="number">60</span>) ? <span class="string">&quot;fail&quot;</span> : <span class="string">&quot;pass&quot;</span></span><br></pre></td></tr></table></figure><ul><li>可以嵌套使用，<strong>右结合律</strong>，从右往左顺序结合<ul><li>可读性下降，不要超过三层</li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">finalgrade = (grade &gt; <span class="number">90</span>) ? <span class="string">&quot;high pass&quot;</span></span><br><span class="line">             : (grade &lt; <span class="number">60</span>) ? <span class="string">&quot;fail&quot;</span> : <span class="string">&quot;pass&quot;</span>;</span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line">finalgrade = (grade &gt; <span class="number">90</span>) ? <span class="string">&quot;high pass&quot;</span></span><br><span class="line">             : （(grade &lt; <span class="number">60</span>) ? <span class="string">&quot;fail&quot;</span> : <span class="string">&quot;pass&quot;</span>）;</span><br></pre></td></tr></table></figure><ul><li>输出表达式使用条件运算符记得加括号，条件运算符优先级条件太低</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cout&lt;&lt; ((grade&lt;<span class="number">60</span>)?<span class="string">&quot;fail&quot;</span>:<span class="string">&quot;pass&quot;</span>);<span class="comment">//pass or fail</span></span><br><span class="line">cout&lt;&lt; (grade&lt;<span class="number">60</span>)?<span class="string">&quot;fail&quot;</span>:<span class="string">&quot;pass&quot;</span>; <span class="comment">//1 or 0 !</span></span><br><span class="line">cout&lt;&lt; grade&lt;<span class="number">60</span>?<span class="string">&quot;fail&quot;</span>:<span class="string">&quot;pass&quot;</span>;<span class="comment">//error cout&lt;60?</span></span><br></pre></td></tr></table></figure><h2 id="练习-5">练习</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//本节的示例程序将成绩划分为high pass、pass 和 fail 三种，</span></span><br><span class="line"><span class="comment">//扩展该程序使其进一步将 60 分到 75 分之间的成绩设定为`low pass`。</span></span><br><span class="line"><span class="comment">//要求程序包含两个版本：一个版本只使用条件运算符；</span></span><br><span class="line"><span class="comment">//另一个版本使用1个或多个`if`语句。哪个版本的程序更容易理解呢？为什么？</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::cin;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">unsigned</span> g; cin &gt;&gt; g;) &#123;</span><br><span class="line"><span class="keyword">auto</span> result = g &gt; <span class="number">90</span> ? <span class="string">&quot;high pass&quot;</span> : g &lt; <span class="number">60</span> ? <span class="string">&quot;fail&quot;</span> :</span><br><span class="line">              g &lt; <span class="number">75</span> ? <span class="string">&quot;low pass&quot;</span> : <span class="string">&quot;pass&quot;</span>;</span><br><span class="line">cout &lt;&lt; result &lt;&lt; endl;</span><br><span class="line"><span class="comment">// -------------------------</span></span><br><span class="line"><span class="keyword">if</span> (g &gt; <span class="number">90</span>) cout &lt;&lt; <span class="string">&quot;high pass&quot;</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (g &lt; <span class="number">60</span>) cout &lt;&lt; <span class="string">&quot;fail&quot;</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (g &lt; <span class="number">75</span>) cout &lt;&lt; <span class="string">&quot;low pass&quot;</span>;</span><br><span class="line"><span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;pass&quot;</span>;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//第二个版本容易理解。当条件运算符嵌套层数变多之后，代码的可读性急剧下降。</span></span><br><span class="line"><span class="comment">//而if else的逻辑很清晰。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//因为运算符的优先级问题，下面这条表达式无法通过编译。</span></span><br><span class="line"><span class="comment">//指出它的问题在哪里？应该如何修改？</span></span><br><span class="line">string s = <span class="string">&quot;word&quot;</span>;</span><br><span class="line">string pl = s + s[s.<span class="built_in">size</span>() - <span class="number">1</span>] == <span class="string">&#x27;s&#x27;</span> ? <span class="string">&quot;&quot;</span> : <span class="string">&quot;s&quot;</span> ;</span><br><span class="line"><span class="comment">//加法运算符的优先级高于条件运算符。因此要改为：</span></span><br><span class="line">string pl = s + (s[s.<span class="built_in">size</span>() - <span class="number">1</span>] == <span class="string">&#x27;s&#x27;</span> ? <span class="string">&quot;&quot;</span> : <span class="string">&quot;s&quot;</span>) ;</span><br></pre></td></tr></table></figure><h1 id="位运算符">位运算符</h1><blockquote><p>提供检查和设置二进制位的功能</p></blockquote><ul><li>位运算符是作用于整数类型的运算对象</li><li>二进制位向左移（&lt;&lt;）或者向右移（&gt;&gt;），移除边界的位就被舍弃掉了</li><li>位取反（~）（逐位求反），与(&amp;)，或(|)，异或(^)</li><li>位运算符遵循左结合律</li></ul><table><thead><tr class="header"><th style="text-align: center;">运算符</th><th style="text-align: center;">功能</th><th style="text-align: center;">用法</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">~</td><td style="text-align: center;">位求反</td><td style="text-align: center;">~expr</td></tr><tr class="even"><td style="text-align: center;">&lt;&lt;</td><td style="text-align: center;">左移</td><td style="text-align: center;">expr&lt;&lt;expr</td></tr><tr class="odd"><td style="text-align: center;">&gt;&gt;</td><td style="text-align: center;">右移</td><td style="text-align: center;">expr&gt;&gt;expr</td></tr><tr class="even"><td style="text-align: center;">&amp;</td><td style="text-align: center;">位与</td><td style="text-align: center;">expr&amp;expr</td></tr><tr class="odd"><td style="text-align: center;">^</td><td style="text-align: center;">位异或</td><td style="text-align: center;">expr^expr</td></tr><tr class="even"><td style="text-align: center;">|</td><td style="text-align: center;">位或</td><td style="text-align: center;">expr|expr</td></tr></tbody></table><ul><li>运算对象是小整型，则自动提升成较大的整型类型</li><li>有符号数负值可能移位后变号，所以强烈建议<strong>位运算符仅用于无符号数</strong></li></ul><h2 id="移位运算符">移位运算符</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//假设char占8位 int占32位</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> bits=<span class="number">0233</span>; <span class="comment">// 八进制0233：000 010 011 011</span></span><br><span class="line"></span><br><span class="line">bits&lt;&lt;<span class="number">8</span>;<span class="comment">//bit提升成整型，向左移动八位</span></span><br><span class="line"><span class="comment">// 00000000 00000000 10011011 00000000</span></span><br><span class="line"></span><br><span class="line">bits&lt;&lt;<span class="number">31</span>;<span class="comment">//向左移动31位，左边超出边界的位舍弃</span></span><br><span class="line"><span class="comment">// 10000000 00000000 00000000 00000000</span></span><br><span class="line"></span><br><span class="line">bits&gt;&gt;<span class="number">3</span>;<span class="comment">//向右移动3位，最右边的3位舍弃</span></span><br><span class="line"><span class="comment">// 00000000 00000000 00000000 00010011</span></span><br></pre></td></tr></table></figure><h2 id="位求反运算符">位求反运算符</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//逐位求反,1-&gt;0,0-&gt;1</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> bits=<span class="number">0227</span>; <span class="comment">// 八进制0227：000 010 010 111</span></span><br><span class="line">~bits;</span><br><span class="line"><span class="comment">// 11111111 11111111 11111111 01101000</span></span><br></pre></td></tr></table></figure><h2 id="位或位与位异或运算符">位或、位与、位异或运算符</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">char</span> b1 = <span class="number">0145</span>; <span class="comment">//01100101</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> b2 = <span class="number">0257</span>; <span class="comment">//10101111</span></span><br><span class="line">b1&amp;b2;<span class="comment">//00000000 00000000 00000000 00100101</span></span><br><span class="line">b1|b2;<span class="comment">//00000000 00000000 00000000 11101111</span></span><br><span class="line">b1^b2;<span class="comment">//00000000 00000000 00000000 11001010</span></span><br></pre></td></tr></table></figure><p><strong>不要把逻辑运算和位运算搞混！</strong></p><h2 id="位运算的应用">位运算的应用</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span> quiz1 = <span class="number">0</span>; <span class="comment">// 每一位代表一个学生是否通过考试</span></span><br><span class="line"><span class="number">1UL</span> &lt;&lt; <span class="number">12</span>; <span class="comment">// 代表第12个学生通过</span></span><br><span class="line">quiz1 |= (<span class="number">1UL</span> &lt;&lt; <span class="number">12</span>); <span class="comment">// 将第12个学生置为已通过</span></span><br><span class="line">quiz1 &amp;= ~(<span class="number">1UL</span> &lt;&lt; <span class="number">12</span>); <span class="comment">// 将第12个学生修改为未通过</span></span><br><span class="line"><span class="type">bool</span> stu12 = quiz1 &amp; (<span class="number">1UL</span> &lt;&lt; <span class="number">12</span>); <span class="comment">// 判断第12个学生是否通过</span></span><br></pre></td></tr></table></figure><ul><li>位运算符使用较少，但是重载版本cout、cin用过，<ul><li>重载运算符的优先级结合律和内置版本一样</li><li>位运算符满足左结合律，优先级介于中间，使用时尽量加括号。</li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; <span class="string">&quot;hi&quot;</span> &lt;&lt; <span class="string">&quot;there&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="comment">//等同于</span></span><br><span class="line">((cout &lt;&lt; <span class="string">&quot;hi&quot;</span>) &lt;&lt; <span class="string">&quot;there&quot;</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="number">42</span> + <span class="number">10</span>; <span class="comment">// 正确 +优先级更高</span></span><br><span class="line">cout &lt;&lt; (<span class="number">10</span> &lt; <span class="number">42</span>); <span class="comment">//括号优先级高</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="number">10</span> &lt; <span class="number">42</span>; <span class="comment">//错误，试图比较cout和42</span></span><br><span class="line"><span class="comment">//等同于</span></span><br><span class="line">(cout &lt;&lt; <span class="number">10</span>) &lt; <span class="number">42</span>;</span><br><span class="line"><span class="comment">//即</span></span><br><span class="line">cout &lt; <span class="number">42</span></span><br></pre></td></tr></table></figure><h2 id="练习-6">练习</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//下列表达式的结果是什么？</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> ul1 = <span class="number">3</span>,ul2 = <span class="number">7</span>;</span><br><span class="line">(a) ul1 &amp; ul2 <span class="comment">//3</span></span><br><span class="line">(b) ul1 | ul2  <span class="comment">//7</span></span><br><span class="line">(c) ul1 &amp;&amp; ul2  <span class="comment">//true</span></span><br><span class="line">(d) ul1 || ul2  <span class="comment">//true</span></span><br></pre></td></tr></table></figure><h1 id="sizeof运算符"><code>sizeof</code>运算符</h1><ul><li>返回一条表达式或一个类型名字所占的<strong>字节数</strong></li><li>返回的类型是<code>size_t</code>的常量表达式</li><li><code>sizeof</code>并不实际计算其运算对象的值</li><li>两种形式：<ul><li><code>sizeof (type)</code>，给出其类型名</li><li><code>sizeof expr</code>，给出表达式</li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对char类型或者类型为char的表达式，执行sizeof运算，结果为1</span></span><br><span class="line"><span class="comment">// 对引用类型执行sizeof运算，得到被引用对象所占空间大小</span></span><br><span class="line"><span class="comment">// 对指针执行sizeof运算，得到指针本身所占空间大小</span></span><br><span class="line"><span class="comment">// 对解引用指针执行sizeof运算，得到指针所指对象所占空间大小，指针不需要有效。</span></span><br><span class="line"><span class="comment">// 对数组执行sizeof运算，得到整个数组所占空间大小</span></span><br><span class="line"><span class="comment">// 对string vector对象执行sizeof运算，只返回固定部分的大小，不会计算对象中元素占用多少空间。</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> ia[<span class="number">10</span>];</span><br><span class="line"><span class="comment">// sizeof(ia)返回整个数组所占空间的大小</span></span><br><span class="line"><span class="comment">// sizeof(ia)/sizeof(*ia)返回数组的大小</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">size_t</span> sz = <span class="built_in">sizeof</span>(ia)/<span class="built_in">sizeof</span>(*ia);</span><br><span class="line"><span class="type">int</span> arr[sz];<span class="comment">//sizeof返回常量</span></span><br></pre></td></tr></table></figure><h2 id="练习-7">练习</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//推断下面代码的输出结果并说明理由。</span></span><br><span class="line"><span class="comment">//实际运行这段程序，结果和你想象的一样吗？如不一样，为什么？</span></span><br><span class="line"><span class="type">int</span> x[<span class="number">10</span>]; <span class="type">int</span> *p = x;</span><br><span class="line">cout &lt;&lt; <span class="built_in">sizeof</span>(x)/<span class="built_in">sizeof</span>(*x) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="built_in">sizeof</span>(p)/<span class="built_in">sizeof</span>(*p) &lt;&lt; endl;</span><br><span class="line">第一个输出结果是 <span class="number">10</span>。第二个结果<span class="number">1</span>,</span><br><span class="line"></span><br><span class="line"><span class="comment">//在下述表达式的适当位置加上括号，使得加上括号之后的表达式的含义与原来的含义相同。</span></span><br><span class="line">(a) <span class="keyword">sizeof</span> x + <span class="built_in">y</span></span><br><span class="line">(b) <span class="keyword">sizeof</span> p-&gt;mem[i]</span><br><span class="line">(c) <span class="keyword">sizeof</span> a &lt; <span class="built_in">b</span></span><br><span class="line">(d) <span class="function"><span class="keyword">sizeof</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="params">(a)</span> <span class="params">(<span class="keyword">sizeof</span> x)</span> + <span class="title">y</span></span></span><br><span class="line"><span class="function"><span class="params">(b)</span> <span class="title">sizeof</span><span class="params">(p-&gt;mem[i])</span></span></span><br><span class="line"><span class="function"><span class="params">(c)</span> <span class="title">sizeof</span><span class="params">(a)</span> &lt; <span class="title">b</span></span></span><br><span class="line"><span class="function"><span class="params">(d)</span> <span class="title">sizeof</span><span class="params">(f())</span></span></span><br></pre></td></tr></table></figure><h1 id="逗号运算符">逗号运算符</h1><ul><li>从左到右依次求值，规定了运算对象的顺序</li><li>首先对左侧求值，然后将求值结果丢弃，逗号运算符结果是右侧表达式的值<ul><li>如果右侧运算对象是左值，那么最终的求值结果也是左值</li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//逗号表达式经常被用在for语句里</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::size_type cnt = ivec.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">for</span>(vector&lt;<span class="type">int</span>&gt;::size_type ix=<span class="number">0</span>;</span><br><span class="line">ix!=ivec.<span class="built_in">size</span>();++ix,--cnt)</span><br><span class="line">ivec[ix]=cnt;</span><br></pre></td></tr></table></figure><h2 id="练习-8">练习</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//解释下面这个循环的含义。</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> size = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> ia[size] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> *ptr = ia, ix = <span class="number">0</span>;</span><br><span class="line">   ix != size &amp;&amp; ptr != ia+size;</span><br><span class="line">   ++ix, ++ptr) &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"><span class="comment">//这个循环在遍历数组ia，指针ptr和整型ix都是起到⼀个循环计数的功能。</span></span><br></pre></td></tr></table></figure><h1 id="类型转换">类型转换</h1><h2 id="隐式类型转换">隐式类型转换</h2><ul><li>自动进行无需介入</li><li>转换设计位尽可能避免损失精度</li></ul><p>下面情况编译器自动转换对象的类型：</p><ul><li>比 int类型小的整数值先提升为较大的整数类型。</li><li>条件中，非布尔转换成布尔。</li><li>初始化中，初始值转换成变量的类型。</li><li>赋值语句，右侧转成左侧。</li><li>算术运算或者关系运算的运算对象有多种类型，要转换成同⼀种类型。</li><li>函数调用时也会有转换。</li></ul><h3 id="算术转换">算术转换</h3><ul><li>运算符的运算对象转成最宽的类型</li></ul><ol type="1"><li>整数提升：</li></ol><ul><li>把小整数类型转换成较大的整数类型</li><li>常见的char、bool、short能存在int就会转换成int，否则提升为unsignedint</li><li>较大的char类型，wchar_t,char16_t,char32_t提升为整型中 int,long,longlong ……最小的，且能容纳原类型所有可能值的类型。</li></ul><ol start="2" type="1"><li>无符号类型的运算对象：</li></ol><ul><li>整型提升 类型匹配则不进行进⼀步转换</li><li>提升后都带符号或都不带符号，小类型运算对象转较⼤的类型</li><li>若无符号不小于带符号类型，则带符号运算对象转成无符号的（可能有副作用）。</li><li>带符号类型大于无符号类型，结果依赖机器。</li></ul><h3 id="理解算数转换">理解算数转换</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//trans.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"><span class="keyword">using</span> std::string;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">bool</span> flag;</span><br><span class="line"><span class="type">char</span> cval;</span><br><span class="line"><span class="type">short</span> sval;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> usval;</span><br><span class="line"><span class="type">int</span> ival;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> uival;</span><br><span class="line"><span class="type">long</span> lval;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> ulval;</span><br><span class="line"><span class="type">float</span> fval;</span><br><span class="line"><span class="type">double</span> dval;</span><br><span class="line"><span class="number">3.1415926L</span> + <span class="string">&#x27;a&#x27;</span>; <span class="comment">//&#x27;a&#x27;提升成int，然后int转成long double</span></span><br><span class="line">dval + ival; <span class="comment">//ival-&gt;double</span></span><br><span class="line">dval + fval; <span class="comment">//fval-&gt;double</span></span><br><span class="line">ival = dval; <span class="comment">//dval-&gt;int,小数部分丢弃</span></span><br><span class="line">flag = dval; <span class="comment">//如果dval非0则真</span></span><br><span class="line">cval + fval; <span class="comment">//cval提升int，int转float</span></span><br><span class="line">sval + cval; <span class="comment">//sval cval -&gt;int</span></span><br><span class="line">cval + lval; <span class="comment">//cval -&gt; long</span></span><br><span class="line">ival + ulval; <span class="comment">//ival-&gt;unsigned int</span></span><br><span class="line">usval + ival; <span class="comment">//根据unsigned short he int 所占空间进行提升</span></span><br><span class="line">uival + lval; <span class="comment">//根据unsigned int 和long所占空间大小进行转换</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="练习-9">练习</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据本节给出的变量定义，说明在下面的表达式中将发生什么样的类型转换：</span></span><br><span class="line">(a) <span class="keyword">if</span> (fval)</span><br><span class="line">(b) dval = fval + ival;</span><br><span class="line">(c) dval + ival * cval;</span><br><span class="line">需要注意每种运算符遵循的是左结合律还是右结合律。</span><br><span class="line">(a) fval 转换为 <span class="type">bool</span> 类型</span><br><span class="line">(b) ival 转换为 <span class="type">float</span> ，相加的结果转换为 <span class="built_in">double</span></span><br><span class="line">(c) cval 转换为 <span class="type">int</span>，然后相乘的结果转换为 <span class="type">double</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> cval;</span><br><span class="line"><span class="type">int</span> ival;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> ui;</span><br><span class="line"><span class="type">float</span> fval;</span><br><span class="line"><span class="type">double</span> dval;</span><br><span class="line">请回答在下⾯的表达式中发⽣了隐式类型转换吗？如果有，指出来。</span><br><span class="line">(a) cval = a + <span class="number">3</span>;</span><br><span class="line">(b) fval = ui - ival * <span class="number">1.0</span>;</span><br><span class="line">(c) dval = ui * fval;</span><br><span class="line">(d) cval = ival + fval + dval;</span><br><span class="line">- (a) a 转换为 <span class="type">int</span> ，然后与 <span class="number">3</span> 相加的结果转换为 <span class="type">char</span></span><br><span class="line">- (b) ival 转换为 <span class="type">double</span>，ui 转换为 <span class="type">double</span>，结果转换为 <span class="type">float</span></span><br><span class="line">- (c) ui 转换为 <span class="type">float</span>，结果转换为 <span class="type">double</span></span><br><span class="line">- (d) ival 转换为 <span class="type">float</span>，与fval相加后的结果转换为 <span class="type">double</span>，最后的结果转换为<span class="type">char</span></span><br></pre></td></tr></table></figure><h2 id="其他隐式类型转换">其他隐式类型转换</h2><ul><li>数组转指针</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ia[<span class="number">10</span>];<span class="comment">//含有十个整数的数组</span></span><br><span class="line"><span class="type">int</span>* ip =ia;<span class="comment">//ia 转换成指向数组首元素的指针</span></span><br></pre></td></tr></table></figure><ol type="1"><li>指针的转换：</li></ol><ul><li>常量指针0和字面值nullptr能转换成任意指针类型</li><li>指向任意非常量的指针能转化成void*</li><li>指向任意对象的指针能转换成const void*</li><li>有继承关系的类型间还有另外⼀种指针转换方式</li></ul><ol start="2" type="1"><li>转成bool类型</li></ol><ul><li>算术类型，指针类型，非0则真</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *cp = <span class="built_in">get_string</span>();</span><br><span class="line"><span class="keyword">if</span>(cp)<span class="comment">//... //cp非0，则真</span></span><br><span class="line"><span class="keyword">while</span>(*p) <span class="comment">//...//*cp 非空字符，则真</span></span><br></pre></td></tr></table></figure><ol start="3" type="1"><li>转换成常量</li></ol><ul><li>允许将指向非常量的指针转换成指向相应常量的指针，引用也如此</li><li>T是⼀种类型，我们就能将T的指针或引用，分别转换成指向const T的指针或引用</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;j =i;<span class="comment">//非常量转为const int 的引用</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *p =&amp;i;<span class="comment">//非常量地址转为const 地址</span></span><br><span class="line"><span class="type">int</span> &amp;r =j,*q=p;<span class="comment">//错误，不允许const 转成非常量</span></span><br><span class="line"><span class="comment">//相反的转换不存在，因为试图删除底层const</span></span><br></pre></td></tr></table></figure><ol start="4" type="1"><li>类类型的转换</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string s, t=<span class="string">&quot;a value&quot;</span>;  <span class="comment">//字面值转为string</span></span><br><span class="line"><span class="keyword">while</span>(cin&gt;&gt;s)<span class="comment">//cin 转为bool</span></span><br><span class="line"><span class="comment">//IO库定义了istream到bool类型的转换，cin自动转为bool值</span></span><br><span class="line"><span class="comment">//bool值由输入流的状态决定 最后一次读入成功true 读入失败false</span></span><br></pre></td></tr></table></figure><h2 id="显式类型转换尽量避免">显式类型转换（尽量避免）</h2><ol type="1"><li>强制类型转换：这种方法本质上是危险的，但有时不得不使用</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i ,j;</span><br><span class="line"><span class="type">double</span> slope = i/j;</span><br></pre></td></tr></table></figure><ol start="2" type="1"><li>命名的强制类型转换 cast-name (expression)</li></ol><ul><li>type 转换目标类型。若是引用，则结果是左值。</li><li>expression ：要转换的值</li><li>cast-name是static_cast,dynamic_cast,const_cast,reinterpret_cast中⼀种</li><li>dynamic_cast支持运行时类型识别</li></ul><ol start="3" type="1"><li>static_cast</li></ol><ul><li>任何明确定义的类型转换，只要不包含底层const，都可以使用。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//进行强制类型转换以便执行浮点数除法</span></span><br><span class="line"><span class="type">double</span> slope = <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(j)/i;</span><br><span class="line"></span><br><span class="line"><span class="comment">//把较大的算数类型赋值给较小的类型时，static_cast非常有用</span></span><br><span class="line"><span class="comment">//告诉编译器不在乎精度损失。使用时警告信息被关闭。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//找回存于void*的指针。编译器无法自动执行的类型转换</span></span><br><span class="line"><span class="type">void</span>* p = &amp;d;<span class="comment">//正确，任何非常量的地址都能存?=入void*</span></span><br><span class="line"><span class="comment">//正确，将void*转换回初始指针类型</span></span><br><span class="line"><span class="type">double</span> * dp = <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(p);</span><br></pre></td></tr></table></figure><ol start="4" type="1"><li>const_cast</li></ol><ul><li>只能改变运算对象的底层const，⼀般可用于去除const性质。</li><li>只有其可以改变常量属性</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span> *pc;</span><br><span class="line"><span class="type">char</span> *p = <span class="built_in">const_cast</span>&lt;<span class="type">char</span>*&gt;(pc);<span class="comment">//正确，但通过p写值是未定义的</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *cp;</span><br><span class="line"><span class="comment">//错误 static_cast不能转换掉const属性</span></span><br><span class="line"><span class="type">char</span> *q = <span class="built_in">static_cast</span>&lt;<span class="type">char</span>*&gt;(cp);</span><br><span class="line"><span class="built_in">static_cast</span>&lt;string&gt;(cp);<span class="comment">//正确，字符串字面值转string</span></span><br><span class="line"><span class="built_in">const_cast</span>&lt;string&gt;(cp);<span class="comment">//错误，const_cast 只改变常量属性</span></span><br><span class="line"><span class="comment">//const_cast 常用于有函数重载的上下文</span></span><br></pre></td></tr></table></figure><ol start="5" type="1"><li>reinterpret_cast</li></ol><ul><li>通常为运算对象的位模式提供低层次上的重新解释。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *ip;</span><br><span class="line"><span class="type">char</span> *pc = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span>*&gt;(ip);</span><br><span class="line"><span class="comment">//必须牢记pc所指的真实对象是int而非char</span></span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">str</span><span class="params">(pc)</span><span class="comment">//可能导致异常运行时行为</span></span></span><br><span class="line"><span class="function"><span class="comment">//类型改了，编译器没有警告出错</span></span></span><br><span class="line"><span class="function"><span class="comment">//语法上全对，查找问题困难。</span></span></span><br></pre></td></tr></table></figure><h2 id="旧式强制类型转换">旧式强制类型转换</h2><ul><li>(type) expr</li><li>type (expr)</li><li>旧式强制转换，表现形式不那么清晰明了，容易看漏，出了问题追踪困难。</li><li>旧式转换， 如果转换const_cast ,static_cast 合法，行为与对应命名转换⼀致。</li><li>如替换不合法，则与reinterpret_cast 类似的功能。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *pc = (<span class="type">char</span>*)ip;<span class="comment">//ip是指向整数的指针</span></span><br><span class="line"><span class="comment">//效果与使用reinterpret_cast 一样。</span></span><br></pre></td></tr></table></figure><h2 id="练习-10">练习</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//假设 i 是int类型，d 是double类型，</span></span><br><span class="line"><span class="comment">//书写表达式 i*=d 使其执⾏整数类型的乘法而非浮点类型的乘法。</span></span><br><span class="line">i *= <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(d);</span><br><span class="line"></span><br><span class="line"><span class="comment">//用命名的强制类型转换改写下列旧式的转换语句。</span></span><br><span class="line"><span class="type">int</span> i; <span class="type">double</span> d; <span class="type">const</span> string *ps; <span class="type">char</span> *pc; <span class="type">void</span> *pv;</span><br><span class="line">(a) pv = (<span class="type">void</span>*)ps;</span><br><span class="line">(b) i = <span class="built_in">int</span>(*pc);</span><br><span class="line">(c) pv = &amp;d;</span><br><span class="line">(d) pc = (<span class="type">char</span>*)pv;</span><br><span class="line">(a) pv = <span class="built_in">static_cast</span>&lt;<span class="type">void</span>*&gt;(<span class="built_in">const_cast</span>&lt;string*&gt;(ps));</span><br><span class="line">(b) i = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(*pc);</span><br><span class="line">(c) pv = <span class="built_in">static_cast</span>&lt;<span class="type">void</span>*&gt;(&amp;d);</span><br><span class="line">(d) pc = <span class="built_in">static_cast</span>&lt;<span class="type">char</span>*&gt;(pv);</span><br><span class="line"></span><br><span class="line"><span class="comment">//说明下面这条表达式的含义。</span></span><br><span class="line"><span class="type">double</span> slope = <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(j/i);</span><br><span class="line">将j/i的结果值转换为<span class="type">double</span>然后赋值给slope。</span><br></pre></td></tr></table></figure><h1 id="运算符优先级表">运算符优先级表</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">::</span><br><span class="line">. -&gt; [] ()</span><br><span class="line">后置++ -- <span class="keyword">typeid</span> <span class="keyword">explicit</span> cast</span><br><span class="line">前置++ -- ~ ! ⼀元- ⼀元+ * &amp; () <span class="keyword">sizeof</span> <span class="keyword">new</span> <span class="keyword">new</span>[] <span class="keyword">delete</span> <span class="keyword">delete</span>[] <span class="keyword">noexcept</span></span><br><span class="line">-&gt;* .*</span><br><span class="line">* / %</span><br><span class="line">+ -</span><br><span class="line">&lt;&lt; &gt;&gt;</span><br><span class="line">&lt; &lt;= &gt; &gt;=</span><br><span class="line">== !=</span><br><span class="line">位&amp;</span><br><span class="line">位^</span><br><span class="line">位|</span><br><span class="line">&amp;&amp;</span><br><span class="line">||</span><br><span class="line">?:</span><br><span class="line">=</span><br><span class="line">*= /= %= += -= &lt;&lt;= &gt;&gt;= &amp;= |= ^=</span><br><span class="line"><span class="keyword">throw</span></span><br><span class="line">,</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;表达式基础&quot;&gt;表达式基础&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;表达式是有一个或多个运算对象(operand)所组成的，对表达式求值将得到的是一个结果(result)。字面值和变量是最简单的表达式(expression)，结果是字面值和变量的值。把一个运算符(operator)和一个或者多个运算对象组合起来可以生成复杂的表达式&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;一元运算符(unary operator)
&lt;ul&gt;
&lt;li&gt;作用与一个运算对象&lt;/li&gt;
&lt;li&gt;如取地址符&lt;code&gt;&amp;amp;&lt;/code&gt;和解引用符&lt;code&gt;*&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;二元运算符(binary operator)
&lt;ul&gt;
&lt;li&gt;作用于两个运算对象&lt;/li&gt;
&lt;li&gt;如相等运算符&lt;code&gt;==&lt;/code&gt;，乘法运算符&lt;code&gt;*&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;三元运算符
&lt;ul&gt;
&lt;li&gt;作用于三个运算对象&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;函数也是一种特殊的运算符
&lt;ul&gt;
&lt;li&gt;对运算对象数量没有限制&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;一些符号既能做一元运算符，也能做二元运算符
&lt;ul&gt;
&lt;li&gt;由上下文决定&lt;/li&gt;
&lt;li&gt;如&lt;code&gt;*&lt;/code&gt;，可用做解引用和乘法&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;组合运算符和运算对象&quot;&gt;组合运算符和运算对象&lt;/h2&gt;
&lt;p&gt;对于含有多个运算符的复杂表达式，要理解：&lt;/p&gt;</summary>
    
    
    
    <category term="后端" scheme="http://lgq007.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="C++" scheme="http://lgq007.github.io/tags/C/"/>
    
    <category term="C" scheme="http://lgq007.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Linux基础</title>
    <link href="http://lgq007.github.io/2023/08/14/Linux%E5%9F%BA%E7%A1%80/"/>
    <id>http://lgq007.github.io/2023/08/14/Linux%E5%9F%BA%E7%A1%80/</id>
    <published>2023-08-14T07:09:19.000Z</published>
    <updated>2023-08-18T15:55:32.105Z</updated>
    
    <content type="html"><![CDATA[<h1 id="文件">文件</h1><h2 id="绪言">绪言</h2><p>在Linux操作系统中秉持着<strong>一切皆文件</strong>的原则，在windows中是文件的，在Linux下也是文件；在Windows中不是文件的，在Linux下同样是文件，它意味着各种设备、资源和数据都可以通过文件系统的方式进行访问和操作。最常见的例子便是用U盘插入电脑中读取信息，在Linux系统中</p><ol type="1"><li><p><code>/dev/sdX</code>：这个文件表示U盘设备，"X"代表具体的设备标识，例如<code>/dev/sda</code>、<code>/dev/sdb</code>等。你可以通过这个文件来访问整个U盘。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">mkdir</span> /media/usb-drive</span><br><span class="line">sudo mount /dev/sdX /media/usb-drive</span><br></pre></td></tr></table></figure></li><li><p><code>/media/username/usb-drive</code>：这个文件夹是U盘挂载的地方，"username"是你的用户名，"usb-drive"是挂载点。在这个文件夹中，你可以通过普通的文件操作来访问U盘中的文件和文件夹。</p></li></ol><p>而在windows操作系统下，U盘通常会被视为两个不同的实体：一个是设备，另一个是文件系统中的一个文件夹</p><ol type="1"><li>设备：可以在Windows设备管理器中看到，通常显示为一个可移动设备。</li><li>文件夹：windows会自动为U盘分配一个盘符，可以用过windows资源管理器访问U盘内的文件。</li></ol><h2 id="linux下的文件目录结构">Linux下的文件目录结构</h2><p><img src="../images/Linux文件目录.png"></p><p>以Ubuntu 22.04 LTS为例，输入<code>ll / -a</code>查看<code>/</code>目录下的文件目录：</p><figure><img src="./../images/Ubuntu文件目录" alt="image-20230814185233037"><figcaption aria-hidden="true">image-20230814185233037</figcaption></figure><ol type="1"><li>常见的目录：</li></ol><ul><li><strong><code>/</code> (根目录)：</strong>Linux文件系统的根目录，所有其他目录都是从这里开始的。</li><li><strong><code>/bin</code> (基本命令)：</strong>全称<code>binary</code>，存放系统启动和维护所需的基本命令，如<code>ls</code>、<code>cp</code>、<code>mv</code>等。</li><li><strong><code>/boot</code> (开机引导)：</strong>存放包含引导启动Linux系统所需的文件，如内核映像文件、引导加载程序以及启动配置文件。</li><li><strong><code>/dev</code> (设备文件)：</strong>包含与系统硬件设备和外部设备的文件，Linux将这些设备抽象为文件，通过这些文件来进行访问和交互。在其中的外接设备是不能直接被使用的，需要<strong>挂载（类似windows下的分配盘符）</strong>。</li><li><strong><code>/etc</code> (系统配置)：</strong>存放系统的配置文件，包括网络配置、用户账户配置、软件配置等。</li><li><strong><code>/home</code> (用户主目录)：</strong>存放用户的主目录，每个用户都有一个独立的子目录，用于存放个人文件、文档和配置文件。</li><li><strong><code>/root</code> (root用户主目录)：</strong>超级用户（root用户）的主目录。</li><li><strong><code>/run</code> (运行时数据)：</strong>用于存放系统启动后运行时需要的临时文件，即进程的运行数据存放目录。</li><li><strong><code>/sbin</code> (系统命令)：</strong>存放系统管理员使用的系统管理命令，这些命令通常需要root权限，如<code>fdisk</code>、<code>iptables</code>等。</li><li><strong><code>/tmp</code> (临时文件)：</strong>用于存放临时文件，系统重新启动后会清空该目录。</li><li><strong><code>/usr</code>(用户目录)：</strong>包含用户程序和文件，通常将大部分软件安装到这个目录下。<ul><li><strong><code>/usr/bin</code>：</strong>存放系统中的大部分用户级别的可执行命令。这些命令通常是系统的标准工具和应用程序，但不是必须在系统启动阶段使用的基本命令。</li><li><strong><code>/usr/local</code>：</strong>程序安装目录。</li><li><strong><code>/usr/sbin</code>：</strong>存放系统管理员（root用户）使用的系统管理命令。与<code>/sbin</code> 目录类似，但 <code>/usr/sbin</code>中的命令通常是不需要在系统启动阶段使用的，因此可以被认为是更为次要的系统命令。</li><li><strong><code>/usr/tmp</code>：</strong>被抛弃临时文件目录。</li><li><strong><code>/usr/lib</code>，<code>/usr/lib32</code>，<code>/usr/lib64</code>，<code>/usr/libx32</code>：</strong>存放系统所需的共享库文件，这些库文件被可执行文件在运行时动态链接以实现代码重用。</li><li><strong><code>/usr/src</code> ：</strong>是用于存放内核源代码（Linux内核）的目录。这个目录通常包含了系统所使用的内核版本的源代码，以及相关的文件和文档。</li></ul></li><li><strong><code>/var</code> (变量数据)：</strong>包含变量数据，如日志文件、数据库文件等会变化的数据。<ul><li><strong><code>/var/tmp</code>：</strong>临时文件目录；存放周期更长</li></ul></li></ul><ol start="2" type="1"><li>其他命令：</li></ol><ul><li><p><strong><code>/media</code> 和 <code>/mnt</code>(挂载点)：</strong>通常用于挂载外部设备，如U盘、光盘等，这样的设备会在这些目录下创建子目录以便访问。</p></li><li><p><strong><code>/opt</code> (可选软件)：</strong>用于存放由第三方提供的附加软件，通常将这些软件安装在这个目录下。</p></li><li><p><strong><code>/proc</code> (进程信息)：</strong>虚拟文件系统，提供有关正在运行的进程和系统状态的信息，以文件的形式呈现。</p></li><li><p><strong><code>/srv</code> (服务数据)：</strong>用于存放系统提供的服务的数据文件，如Web服务器的文档。</p></li><li><p><strong><code>/sys</code> (内核文件)：</strong>用于访问内核的运行时信息，以及与内核模块的交互。</p></li><li><p><strong><code>/snap</code>(包管理器)：</strong>是用于存放使用Snap 包管理器安装的应用程序和软件包的目录。</p></li></ul><h2 id="文件路径">文件路径</h2><p>在 Linux操作系统中，文件路径是用来描述文件在文件系统中位置的字符串。Linux的文件路径是一个层次化的结构，从根目录开始，通过目录名和斜杠（/）来指示文件的位置。</p><ol type="1"><li><strong>绝对路径：</strong>绝对路径从根目录开始，指示完整的路径。例如：<ul><li><code>/usr/bin</code>：指向根目录下的 <code>/usr/bin</code>目录。</li><li><code>/home/user/documents/file.txt</code>：指向根目录下的<code>/home/user/documents</code> 目录中的 <code>file.txt</code>文件。</li></ul></li><li><strong>相对路径：</strong>相对路径是<strong>相对于当前工作目录的路径。</strong>例如，如果当前工作目录是<code>/home/user</code>，那么：<ul><li><code>documents/file.txt</code>：指向<code>/home/user/documents</code> 目录中的 <code>file.txt</code>文件。</li></ul></li><li><strong>特殊符号：</strong> 在路径中，一些特殊符号有特殊的含义：<ul><li><code>.</code>：代表当前目录。例如：<code>./file.txt</code>表示当前目录中的 <code>file.txt</code> 文件。</li><li><code>..</code>：代表上一级目录。例如：<code>../folder/file.txt</code>表示上一级目录中的 <code>folder</code> 目录下的 <code>file.txt</code>文件。</li><li><code>~</code>：代表当前用户的主目录。例如：<code>~/documents</code>表示当前用户的主目录下的 <code>documents</code> 目录。</li></ul></li><li><strong>环境变量：</strong> 有些路径中可能包含环境变量，例如<code>$HOME</code>代表当前用户的主目录。例如：<code>$HOME/documents</code> 表示主目录下的<code>documents</code> 目录。</li></ol><h2 id="文件命名规则">文件命名规则</h2><p>常见的 Linux 文件命名规则：</p><ol type="1"><li><strong>大小写敏感：</strong> Linux文件系统是大小写敏感的。例如，<code>file.txt</code> 和<code>File.txt</code> 被认为是两个不同的文件。</li><li><strong>字母、数字和下划线：</strong>文件名可以包含字母（大小写）、数字和下划线字符。文件名不能以数字开头。</li><li><strong>连字符和点：</strong>文件名中可以包含连字符（减号，短划线）和点（句点），但不能以它们开头或结尾。连字符通常用于分隔单词，而点通常用于文件名的扩展名。</li><li><strong>扩展名：</strong> Linux 中的文件命名并不像 Windows那样依赖于扩展名来识别文件类型。文件名可以没有扩展名，也可以使用任何合法的字符作为扩展名。</li><li><strong>保留字符：</strong> Linux文件名中不能包含特殊的保留字符，如斜杠（/）、问号（?）等。</li><li><strong>长度限制：</strong> 文件名的最大长度为 255 个字符。</li></ol><p>注意：</p><ul><li><p>以<code>.</code>开头的文件名是隐藏文件，使用<code>ls</code>命令时要添加命令选项<code>-a</code>方可查看。</p></li><li><p>虽说Linux可以使用特殊字符作为文件名，但一般不推荐使用特殊字符。</p></li></ul><p>例如：用（空格）当作文件名；在Ubuntu下系统会以引号显示该文件，但有的Linux版本可能会直接不显示该文件。文件名的含义尽量给文件命名以反映其内容、用途或功能，以便其他人能够轻松理解和识别文件。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">exiler@localhost:~$ <span class="built_in">touch</span> <span class="string">&#x27; &#x27;</span></span><br><span class="line">exiler@localhost:~$ <span class="built_in">ls</span></span><br><span class="line"><span class="string">&#x27; &#x27;</span>   book   gitclone_file   <span class="built_in">test</span>   </span><br></pre></td></tr></table></figure><h1 id="命令">命令</h1><blockquote><p>Linux是一种类Unix操作系统，近些年来Linux的桌面版本层出不穷，一定程度上极大简化了Linux的个人使用。面对server等版本，掌握shell终端命令的使用可以更加方便快速的操作Linux。</p></blockquote><h2 id="目录操作命令">目录操作命令</h2><h3 id="查看路径">查看路径</h3><ul><li><code>pwd</code> 查看当前路径，Print Working Directory的缩写</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">exiler@localhost:~$ <span class="built_in">pwd</span></span><br><span class="line">/home/exiler</span><br></pre></td></tr></table></figure><h3 id="创建目录">创建目录</h3><ul><li><code>mkdir</code> 一次建立一个或几个目录</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">exiler@localhost:~$ <span class="built_in">mkdir</span> document picture  <span class="comment">#新建目录</span></span><br><span class="line">exiler@localhost:~$ <span class="built_in">ls</span></span><br><span class="line">document  picture</span><br><span class="line"></span><br><span class="line">exiler@localhost:~$ <span class="built_in">mkdir</span> ~/picture/temp  <span class="comment">#创建子目录</span></span><br><span class="line">exiler@localhost:~$ <span class="built_in">ls</span> ~/picture/</span><br><span class="line">temp</span><br></pre></td></tr></table></figure><p>创建子目录默认为为已存在的目录创建子目录，若想要完整地创建一个不存在目录结构，请使用<code>mkdir -p</code>指令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">exiler@localhost:~$ mkdir ~/tempx/job  #error</span><br><span class="line">mkdir: cannot create directory ‘/home/exiler/tempx/job’: No such file or directory  </span><br><span class="line">exiler@localhost:~$ mkdir -p ~/tempx/job   #true</span><br><span class="line">exiler@localhost:~$ ls</span><br><span class="line">document  picture  tempx</span><br><span class="line">exiler@localhost:~$ ls ~/tempx/</span><br><span class="line">job</span><br></pre></td></tr></table></figure><h3 id="移动目录">移动目录</h3><ul><li><code>mv</code>move的缩写，可以用来移动文件，也可以用于重命名文件</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">mv</span> <span class="built_in">source</span> destination</span></span><br><span class="line">exiler@localhost:~$ tree</span><br><span class="line">.</span><br><span class="line">├── document</span><br><span class="line">├── picture</span><br><span class="line">│   └── temp</span><br><span class="line">└── tempx</span><br><span class="line">    └── job</span><br><span class="line">    </span><br><span class="line">5 directories, 0 files</span><br><span class="line">exiler@localhost:~$ mv ~/picture/temp document/ #移动文件</span><br><span class="line">exiler@localhost:~$ tree</span><br><span class="line">.</span><br><span class="line">├── document</span><br><span class="line">│   └── temp</span><br><span class="line">├── picture</span><br><span class="line">└── tempx</span><br><span class="line">    └── job</span><br></pre></td></tr></table></figure><p>若source文件与的destination目录下的某个文件存在文件名相同的情况，则mv命令会不发出警告地把destination目录下的同名文件替换，导致某些重要文件丢失。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">exiler@localhost:~$ <span class="built_in">mkdir</span> ~/test &amp;&amp; <span class="built_in">cd</span> <span class="built_in">test</span></span><br><span class="line">exiler@localhost:~/test$ <span class="built_in">echo</span> <span class="string">&quot;hello&quot;</span> &gt; hello</span><br><span class="line">exiler@localhost:~/test$ <span class="built_in">cat</span> hello</span><br><span class="line">hello</span><br><span class="line">exiler@localhost:~/test$ <span class="built_in">cd</span> .. &amp;&amp; <span class="built_in">touch</span> hello</span><br><span class="line">exiler@localhost:~$ <span class="built_in">mv</span> hello <span class="built_in">test</span>/ &amp;&amp; <span class="built_in">cat</span> hello</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>为了杜绝此类情况，可以使用<code>mv -i</code>选项：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">exiler@localhost:~$ <span class="built_in">ls</span></span><br><span class="line">document  hello  picture  tempx  <span class="built_in">test</span></span><br><span class="line">exiler@localhost:~$ <span class="built_in">mv</span> -i hello <span class="built_in">test</span>/</span><br><span class="line"><span class="built_in">mv</span>: overwrite <span class="string">&#x27;test/hello&#x27;</span>? <span class="comment">#系统发出提示，回答n表示跳过，回答y表示覆盖</span></span><br></pre></td></tr></table></figure><p>也可以使用<code>mv -b</code>选项给source文件名添加字符<code>~</code>避免被覆盖：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">exiler@localhost:~$ <span class="built_in">touch</span> <span class="string">&quot;hello&quot;</span></span><br><span class="line">exiler@localhost:~$ <span class="built_in">mv</span> -b hello <span class="built_in">test</span>/</span><br><span class="line">exiler@localhost:~$ <span class="built_in">ls</span></span><br><span class="line">document  picture  tempx  <span class="built_in">test</span></span><br><span class="line">exiler@localhost:~$ <span class="built_in">ls</span> <span class="built_in">test</span>/</span><br><span class="line">hello  hello~</span><br></pre></td></tr></table></figure><ul><li>重命名</li></ul><p>Linux中并没有专门用来重命名的命令，因为mv命令可以轻松实现文件重命名</p><p>例如，如果要将文件 "oldname.txt" 重命名为"newname.txt"，你可以使用以下命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mv</span> oldname.txt newname.txt</span><br></pre></td></tr></table></figure><h3 id="删除目录">删除目录</h3><ul><li><code>rmdir</code>用来<strong>删除空目录</strong>，后跟要删除的空目录名即可。</li><li><code>rm</code>用来删除文件</li></ul><p>rm命令的使用方式较多，可以一次删除一个或几个文件，也可以用来删除目录。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">rm</span> <span class="built_in">test</span>/*.php  <span class="comment">#删除test目录下的所有php文件</span></span><br></pre></td></tr></table></figure><p>为了安全起见，使用<code>rm -i</code>命令系统会发出请求等待用户是否确定删除文件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">exiler@localhost:~$ <span class="built_in">rm</span> -i hello</span><br><span class="line"><span class="built_in">rm</span>: remove regular empty file <span class="string">&#x27;hello&#x27;</span>? </span><br><span class="line"><span class="comment">#答y表示确认删除，答n表示跳过。对于只读文件,不加上-i选项，rm命令也会提示</span></span><br></pre></td></tr></table></figure><p>使用<code>rm -f</code>可以避免这样的交互操作，<code>rm</code>命令会自动对这些文件回答y，一般<code>-f</code>选项都是配合<code>-r</code>选项使用删除整个目录。</p><ul><li>使用<code>rm -r</code>递归删除整个目录：</li></ul><p><code>rm -r</code>命令会递归删除一个目录下的所有文件和子目录下的文件，最后再删除选中的目录。使用该命令时要格外小心，特别是以root身份执行该命令。</p><h3 id="复制目录">复制目录</h3><ul><li><code>cp</code></li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cp</span> <span class="built_in">source</span> destination</span><br></pre></td></tr></table></figure><p>和<code>mv</code>命令一样，<code>cp</code>默认情况下会也会覆盖目标目录中的同名文件。</p><ol type="1"><li>可以使用-i选项对这种情况进行提示.</li><li>可以使用-b选项对同名文件改名后再复制。这两个选项的使用和mv命令中一样。</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cp</span> test.php <span class="built_in">test</span>/  </span><br><span class="line"></span><br><span class="line">exiler@localhost:~$ <span class="built_in">cp</span> -i hello.php picture/</span><br><span class="line"><span class="built_in">cp</span>: overwrite <span class="string">&#x27;picture/hello.php&#x27;</span>?</span><br><span class="line"></span><br><span class="line">exiler@localhost:~$ <span class="built_in">cp</span> -b hello.php picture/</span><br><span class="line">exiler@localhost:~$ <span class="built_in">ls</span> picture/</span><br><span class="line">hello.php  hello.php~</span><br></pre></td></tr></table></figure><h3 id="跳转目录">跳转目录</h3><ul><li><code>cd</code>命令可以用来切换工作目录，ChangeDirectory的缩写.</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ../ <span class="comment">#返回上级目录</span></span><br><span class="line"><span class="built_in">cd</span> ../.. <span class="comment">#返回上级目录的上级目录，以此类推</span></span><br><span class="line"><span class="built_in">cd</span>  <span class="comment">#返回用户目录</span></span><br><span class="line"><span class="built_in">cd</span> ~ <span class="comment">#返回用户目录</span></span><br><span class="line"><span class="built_in">cd</span> /usr/bin <span class="comment">#进入usr目录下的bin目录</span></span><br></pre></td></tr></table></figure><p>使用<code>cd</code>命令时要注意区分相对路径和绝对路径的使用。</p><h2 id="文件操作命令">文件操作命令</h2>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;文件&quot;&gt;文件&lt;/h1&gt;
&lt;h2 id=&quot;绪言&quot;&gt;绪言&lt;/h2&gt;
&lt;p&gt;在Linux操作系统中秉持着&lt;strong&gt;一切皆文件&lt;/strong&gt;的原则，在windows中是文件的，在Linux下也是文件；在Windows中不是文件的，在Linux下同样是文件，它意味着各种设备、资源和数据都可以通过文件系统的方式进行访问和操作。最常见的例子便是用U盘插入电脑中读取信息，在Linux系统中&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;/dev/sdX&lt;/code&gt;：这个文件表示U盘设备，&quot;X&quot;代表具体的设备标识，例如&lt;code&gt;/dev/sda&lt;/code&gt;、&lt;code&gt;/dev/sdb&lt;/code&gt;等。你可以通过这个文件来访问整个U盘。&lt;/p&gt;
&lt;figure class=&quot;highlight sh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;sudo &lt;span class=&quot;built_in&quot;&gt;mkdir&lt;/span&gt; /media/usb-drive&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sudo mount /dev/sdX /media/usb-drive&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;/media/username/usb-drive&lt;/code&gt;：这个文件夹是U盘挂载的地方，&quot;username&quot;是你的用户名，&quot;usb-drive&quot;是挂载点。在这个文件夹中，你可以通过普通的文件操作来访问U盘中的文件和文件夹。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;而在windows操作系统下，U盘通常会被视为两个不同的实体：一个是设备，另一个是文件系统中的一个文件夹&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="http://lgq007.github.io/categories/Linux/"/>
    
    
    <category term="Linux" scheme="http://lgq007.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>C ++入门-2</title>
    <link href="http://lgq007.github.io/2023/08/03/C++%20%E5%85%A5%E9%97%A8-2/"/>
    <id>http://lgq007.github.io/2023/08/03/C++%20%E5%85%A5%E9%97%A8-2/</id>
    <published>2023-08-03T12:23:37.000Z</published>
    <updated>2023-08-04T10:12:10.132Z</updated>
    
    <content type="html"><![CDATA[<h1 id="命名空间的using声明">命名空间的using声明</h1><ul><li>使用某个命名空间：例如<code>using std::cin</code>表示使用命名空间<code>std</code>中的名字<code>cin</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//using1.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">// using 声明，当我们使用cin时，从命名空间std中获取</span></span><br><span class="line"><span class="keyword">using</span> std::cin;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line">cin &gt;&gt; i;<span class="comment">//正确 cin和std::cin含义相同</span></span><br><span class="line"><span class="comment">// cout &lt;&lt; i; //错误 没有对应的using声明，必须使用完整的名字</span></span><br><span class="line">    <span class="comment">//[Error] &#x27;cout&#x27; was not declared in this scope; did you mean &#x27;std::cout&#x27;?</span></span><br><span class="line">std::cout &lt;&lt; i; <span class="comment">//正确 显示地从std中使用cout</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个名字都需要独立的USING声明</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//using2.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">// using declarations for names from the standard library</span></span><br><span class="line"><span class="keyword">using</span> std::cin;</span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Enter two numbers:&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="type">int</span> v1, v2;</span><br><span class="line">cin &gt;&gt; v1 &gt;&gt; v2;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;The sum of &quot;</span> &lt;&lt; v1 &lt;&lt; <span class="string">&quot; and &quot;</span> &lt;&lt; v2</span><br><span class="line">     &lt;&lt; <span class="string">&quot; is &quot;</span> &lt;&lt; v1 + v2 &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>头文件中不应该包含using声明。<ul><li>头文件的内容会拷贝到所有引用它的文件中去，可能产生名字冲突。</li><li>标准库内的名字和对应的头文件均可以在网上查到，在此不做赘述。</li></ul></li></ul><h1 id="标准库类型-string">标准库类型 string</h1><ul><li>标准库类型string表示可变长的字符序列。</li><li>使用string类型必须首先包含string头文件。</li><li>标准库类型对⼀般应用场合有足够的效率</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::string;</span><br></pre></td></tr></table></figure><p><strong>string对象不同于字符串字面值！</strong></p><h2 id="定义和初始化string对象">定义和初始化string对象</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化string对象的⽅式：</span></span><br><span class="line">string s1; <span class="comment">// 默认初始化，s1是个空字符串</span></span><br><span class="line"><span class="function">string <span class="title">s2</span><span class="params">(s1)</span></span>; <span class="comment">// s2是s1的副本</span></span><br><span class="line">string s2 = s1; <span class="comment">// 等价于s2(s1)，s2是s1的副本</span></span><br><span class="line"><span class="function">string <span class="title">s3</span><span class="params">(<span class="string">&quot;value&quot;</span>)</span></span>; <span class="comment">// s3是字面值&quot;value&quot;的副本，除字面值最后的那个空字符外 </span></span><br><span class="line">string s3 = <span class="string">&quot;value&quot;</span>; <span class="comment">// 等价于s3(&quot;value&quot;)，s3是字面值&quot;value&quot;的副本</span></span><br><span class="line"><span class="function">string <span class="title">s4</span><span class="params">(n,<span class="string">&#x27;c&#x27;</span>)</span></span>; <span class="comment">// 把s4初始化为由连续n个字符c组成的串</span></span><br><span class="line">string s5 = <span class="string">&quot;hiya&quot;</span>; <span class="comment">// 拷贝初始化</span></span><br><span class="line"><span class="function">string <span class="title">s6</span><span class="params">(<span class="string">&quot;hiya&quot;</span>)</span></span>; <span class="comment">// 直接初始化</span></span><br><span class="line"><span class="function">string <span class="title">s7</span><span class="params">(<span class="number">10</span>,<span class="string">&#x27;c&#x27;</span>)</span></span>; <span class="comment">// 直接初始化，s7的内容是&quot;cccccccccc&quot;</span></span><br><span class="line">string s8=<span class="built_in">string</span>(<span class="number">10</span>,<span class="string">&#x27;c&#x27;</span>);<span class="comment">//拷贝初始化，s8的内容是&quot;cccccccccc&quot;</span></span><br><span class="line"><span class="function">string <span class="title">temp</span><span class="params">(<span class="number">10</span>,<span class="string">&#x27;c&#x27;</span>)</span></span>; <span class="comment">// temp的内容是&quot;cccccccccc&quot;</span></span><br><span class="line">string s8= temp; <span class="comment">// 将temp拷贝给s8。</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">拷贝初始化（copy initialization）：</span></span><br><span class="line"><span class="comment">使用等号=将⼀个已有的对象拷贝到正在创建的对象。</span></span><br><span class="line"><span class="comment">直接初始化（direct initialization）：</span></span><br><span class="line"><span class="comment">通过括号给对象赋值。</span></span><br><span class="line"><span class="comment">**/</span></span><br></pre></td></tr></table></figure><h2 id="string对象上的操作">string对象上的操作</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">os &lt;&lt; s; <span class="comment">// 将s写到输出流os当中，返回os</span></span><br><span class="line">is &gt;&gt; s; <span class="comment">// 从is中读取字符串赋给s，字符串以空白分割，返回is</span></span><br><span class="line"><span class="built_in">getline</span>(is, s); <span class="comment">// 从is中读取⼀行赋给s，返回is</span></span><br><span class="line">s.<span class="built_in">empty</span>(); <span class="comment">// s为空返回true，否则返回false</span></span><br><span class="line">s.<span class="built_in">size</span>(); <span class="comment">// 返回s中字符的个数</span></span><br><span class="line">s[n]; <span class="comment">// 返回s中第n个字符的引用，位置n从0计起</span></span><br><span class="line">s1+s2; <span class="comment">// 返回s1和s2连接后的结果</span></span><br><span class="line">s1=s2; <span class="comment">// 用s2的副本代替s1中原来的字符</span></span><br><span class="line">s1==s2; <span class="comment">// 如果s1和s2中所含的字符完全⼀样，则它们相等；</span></span><br><span class="line"><span class="comment">// string对象的相等性判断, 对字母的大小写敏感。</span></span><br><span class="line">s1!=s2; <span class="comment">// 同上</span></span><br><span class="line">&lt;, &lt;=, &gt;, &gt;= <span class="comment">// 利用字符在字典中的顺序进行比较，且对字母的⼤⼩写敏感</span></span><br></pre></td></tr></table></figure><h2 id="读写string对象">读写string对象</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//stringIO.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::string;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::cin;</span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">string s; <span class="comment">// empty string</span></span><br><span class="line">cin &gt;&gt; s; <span class="comment">// read a whitespace-separated string into s</span></span><br><span class="line">cout &lt;&lt; s &lt;&lt; endl; <span class="comment">// write s to the output</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多个输入输出可以连写">多个输入输出可以连写</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//stringIO2.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::string;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::cin;</span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">string s1, s2;</span><br><span class="line">cin &gt;&gt; s1 &gt;&gt; s2; <span class="comment">// read first input into s1, second into s2</span></span><br><span class="line">cout &lt;&lt; s1 &lt;&lt; s2 &lt;&lt; endl; <span class="comment">// write both strings</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>执行读操作&gt;&gt;：忽略掉开头的空白（包括空格，换行符，制表符等），直到遇到下一处空白为止。</li></ul><h2 id="读取位置数量的string对象">读取位置数量的string对象</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//stringIO3.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::cin;</span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::string;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">string word;</span><br><span class="line"><span class="keyword">while</span> (cin &gt;&gt; word) <span class="comment">// read until end-of-file. ctrl+d(linux) ctrl+c(windows)</span></span><br><span class="line">cout &lt;&lt; word &lt;&lt; endl; <span class="comment">// write each word followed by a new line</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用getline读取一整行">使用getline读取一整行</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//stringGetline.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::string;</span><br><span class="line"><span class="keyword">using</span> std::getline;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::cin;</span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">string line;</span><br><span class="line"><span class="comment">// read input a line at a time until end-of-file</span></span><br><span class="line"><span class="comment">// line 中不包含换行符</span></span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">getline</span>(cin, line))</span><br><span class="line">cout &lt;&lt; line &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>getline</code>：读取一整行，包含空白符。</li></ul><h2 id="string的empty和size操作">string的empty和size操作</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//stringEmpty.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::string;</span><br><span class="line"><span class="keyword">using</span> std::cin;</span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">string line;</span><br><span class="line"><span class="comment">// 每次读入一行，遇到空格直接跳过</span></span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">getline</span>(cin, line))</span><br><span class="line"><span class="keyword">if</span> (!line.<span class="built_in">empty</span>())</span><br><span class="line">cout &lt;&lt; line &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//stringSize.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::string;</span><br><span class="line"><span class="keyword">using</span> std::getline;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::cin;</span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">string line;</span><br><span class="line"><span class="comment">// read input a line at a time and print lines that are longer than 80 characters</span></span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">getline</span>(cin, line))</span><br><span class="line"><span class="keyword">if</span> (line.<span class="built_in">size</span>() &gt; <span class="number">80</span>)</span><br><span class="line">cout &lt;&lt; line &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="stringsize_type类型">STRING::SIZE_TYPE类型</h2><ul><li><code>s.size()</code>返回<code>string::size_type</code>类型，是⼀个<strong>无符号</strong>类型的值，不要和<code>int</code>混用</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> len = line.<span class="built_in">size</span>(); <span class="comment">//len的类型是string::size_type类型</span></span><br></pre></td></tr></table></figure><ul><li>假设n是⼀个负值int，则<code>line.size()</code> &lt;n几乎肯定是true，因为负值n会自动转化成一个比较大的无符号值。</li><li>表达式里有<code>size()</code>函数就不要使用<code>int</code>，避免混用<code>int</code>和<code>unsigned</code>可能带来的问题</li></ul><h2 id="比较string对象">比较string对象</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//stringCompare.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::string;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">string str = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">string phrase = <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line">string slang = <span class="string">&quot;Hiya&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (str &lt; phrase) cout &lt;&lt; <span class="string">&quot;Hello &lt; Hello World&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">if</span> (slang &gt; str) cout &lt;&lt; <span class="string">&quot;Hiya &gt; Hello&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">if</span> (slang &gt; phrase) cout &lt;&lt; <span class="string">&quot;Hiya &gt; Hello World&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Hello &lt; Hello World</span></span><br><span class="line"><span class="comment">//Hiya &gt; Hello</span></span><br><span class="line"><span class="comment">//Hiya &gt; Hello World</span></span><br></pre></td></tr></table></figure><h2 id="为string对象赋值">为string对象赋值</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对于string类而言，允许把⼀个对象的值赋给另外⼀个对象</span></span><br><span class="line"><span class="function">string <span class="title">st1</span><span class="params">(<span class="number">10</span>,<span class="string">&#x27;c&#x27;</span>)</span>,st2</span>; <span class="comment">//st1是&quot;cccccccccc&quot;,st2是空字符串</span></span><br><span class="line">st1 = st2; <span class="comment">//⽤st2的副本替换st1的内容</span></span><br><span class="line"><span class="comment">//此时st1和st2都是空字符串</span></span><br></pre></td></tr></table></figure><h2 id="字面值和string对象相加">字面值和string对象相加</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//标准库允许把字符字面值和字符串字面值转换成string对象</span></span><br><span class="line"><span class="comment">//所以在需要stirng对象的地方可以使用这两种字面值替代</span></span><br><span class="line"><span class="comment">//stringAdd.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::string;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">string s1  = <span class="string">&quot;hello, &quot;</span>, s2 = <span class="string">&quot;world&quot;</span>;</span><br><span class="line">string s3 = s1 + <span class="string">&quot;,&quot;</span> + s2 + <span class="string">&#x27;\n&#x27;</span>;   <span class="comment">// s3 is hello, world\n</span></span><br><span class="line">cout &lt;&lt; s1 &lt;&lt; s2 &lt;&lt; endl &lt;&lt; s3 &lt;&lt; endl;</span><br><span class="line">string s4 = s1 + <span class="string">&quot;,&quot;</span> ;               <span class="comment">// ok,string+&quot;,&quot;</span></span><br><span class="line"><span class="comment">//string s5 = &quot;hello&quot;+&quot;,&quot;;            //error, &quot; &quot;+&quot; &quot;</span></span><br><span class="line">string s6 = s1 + <span class="string">&quot;,&quot;</span> + <span class="string">&quot;world&quot;</span>;</span><br><span class="line"><span class="comment">//string s7=&quot;hello&quot;+&quot;,&quot;+s2;           //error, &quot; &quot;+&quot; &quot;</span></span><br><span class="line">cout &lt;&lt; s4 &lt;&lt; endl &lt;&lt; s6 &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 字符串字面值和string是不同的类型。</span></span><br></pre></td></tr></table></figure><h2 id="练习">练习</h2><ol type="1"><li>编写⼀段程序从标准输入中一次读入一行，然后修改该程序使其一次读入⼀个词。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//⼀次读入一行：</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::string;<span class="keyword">using</span> std::cin;<span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;<span class="keyword">using</span> std::getline;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">string s;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">getline</span>(cin,s))</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//一次读入一个词</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::string;<span class="keyword">using</span> std::cin;<span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;<span class="keyword">using</span> std::getline;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">string s;</span><br><span class="line"><span class="keyword">while</span> (cin &gt;&gt; s)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2" type="1"><li>编写一段程序从标准输入中读入多个字符串并将他们连接起来，输出连接成的大字符串。然后修改上述程序，用空格把输入的多个字符串分割开来。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//连接</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::string;<span class="keyword">using</span> std::cin;</span><br><span class="line"><span class="keyword">using</span> std::cout;<span class="keyword">using</span> std::endl;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string result, s;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; s)</span><br><span class="line">    &#123;</span><br><span class="line">        result += s;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; result &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//分割</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::string;<span class="keyword">using</span> std::cin;</span><br><span class="line"><span class="keyword">using</span> std::cout;<span class="keyword">using</span> std::endl;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string result, s;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; s)</span><br><span class="line">    &#123;</span><br><span class="line">        result += s + <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; result &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="处理string对象中的字符">处理string对象中的字符</h2><ul><li><code>cctype</code>头文件定义了一组标准库函数关于字符特性。</li><li>C++修改了C的标准库，名称为去掉.h，前面加c<ul><li>c++版本为<code>cctype</code> ， c版本为<code>ctype.h</code></li><li>尽量使用c++版本的头文件，即<code>cctype</code></li></ul></li></ul><p><code>cctype</code>头文件中定义了⼀组标准函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">isalnum</span>(c) 当c是字母或数字时为真</span><br><span class="line"><span class="built_in">isalpha</span>(c) 当c是字母时为真</span><br><span class="line"><span class="built_in">iscntrl</span>(c) 当c是控制字符时为真</span><br><span class="line"><span class="built_in">isdigit</span>(c) 当c是数字时为真</span><br><span class="line"><span class="built_in">isgraph</span>(c) 当c不是空格但可以打印时为真</span><br><span class="line"><span class="built_in">islower</span>(c) 当c是⼩写字母时为真</span><br><span class="line"><span class="built_in">isprint</span>(c) 当c是可打印字符时为真</span><br><span class="line"><span class="built_in">ispunct</span>(c) 当c是标点符号时为真</span><br><span class="line"><span class="built_in">isspace</span>(c) 当c是空白时为真</span><br><span class="line">    （空格、横向制表符、纵向制表符、回车符、换行符、进纸符）</span><br><span class="line"><span class="built_in">isupper</span>(c) 当c是⼤写字母时为真</span><br><span class="line"><span class="built_in">isxdigit</span>(c) 当c是十六进制数字时为真</span><br><span class="line"><span class="built_in">tolower</span>(c) 当c是⼤写字母，输出对应的⼩写字母；否则原样输出<span class="function">c</span></span><br><span class="line"><span class="function"><span class="title">toupper</span><span class="params">(c)</span> 当c是⼩写字母，输出对应的⼤写字母；否则原样输出c</span></span><br></pre></td></tr></table></figure><h2 id="使用for语句处理每个字符">使用for语句处理每个字符</h2><ul><li><p>语法形式</p></li><li><p>```cpp for(declaration: expression) statement<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">+ expression是⼀个对象，用于表示⼀个序列 ，declaration负责定义⼀个变量，用于访问序列中基础元素 </span><br><span class="line"></span><br><span class="line">+ 每次迭代，declaration部分变量初始化为expression部分的下⼀个元素值</span><br><span class="line"></span><br><span class="line">```cpp</span><br><span class="line">for (auto c: str) </span><br><span class="line"> statement </span><br></pre></td></tr></table></figure></p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;c: str)<span class="comment">//使用引用直接改变字符串中的字符。 </span></span><br><span class="line">statement</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//stringFor.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::string;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="function">string <span class="title">str</span><span class="params">(<span class="string">&quot;some string&quot;</span>)</span></span>;</span><br><span class="line"><span class="comment">//每次输出str中的一个字符</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> c : str)</span><br><span class="line">cout &lt;&lt; c &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">s</span></span><br><span class="line"><span class="comment">o</span></span><br><span class="line"><span class="comment">m</span></span><br><span class="line"><span class="comment">e</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">s</span></span><br><span class="line"><span class="comment">t</span></span><br><span class="line"><span class="comment">r</span></span><br><span class="line"><span class="comment">i</span></span><br><span class="line"><span class="comment">n</span></span><br><span class="line"><span class="comment">g</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//stringFor2.cpp</span></span><br><span class="line"><span class="comment">//统计标点符号</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::string;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::ispunct;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="function">string <span class="title">s</span><span class="params">(<span class="string">&quot;Hello World!!!&quot;</span>)</span></span>;</span><br><span class="line"><span class="comment">// punct_cnt has the same type that s.size returns</span></span><br><span class="line"><span class="keyword">decltype</span>(s.<span class="built_in">size</span>()) punct_cnt = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// count the number of punctuation characters in s</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> c : s) <span class="comment">// for every char in s</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">ispunct</span>(c)) <span class="comment">// if the character is punctuation</span></span><br><span class="line">++punct_cnt; <span class="comment">// increment the punctuation counter</span></span><br><span class="line">cout &lt;&lt; punct_cnt</span><br><span class="line">     &lt;&lt; <span class="string">&quot; punctuation characters in &quot;</span> &lt;&lt; s &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3 punctuation characters in Hello World!!!</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//stringFor3.cpp</span></span><br><span class="line"><span class="comment">//字符串改大写</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::string;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::isupper;</span><br><span class="line"><span class="keyword">using</span> std::toupper;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="function">string <span class="title">s</span><span class="params">(<span class="string">&quot;Hello World!!!&quot;</span>)</span></span>;</span><br><span class="line"><span class="comment">// convert s to uppercase</span></span><br><span class="line">string orig = s;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;c : s)   <span class="comment">// for every char in s (note: c is a reference)</span></span><br><span class="line"><span class="comment">// c is a reference, so this assignment changes the char in s</span></span><br><span class="line">c = <span class="built_in">toupper</span>(c);</span><br><span class="line">cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//HELLO WORLD!!!</span></span><br></pre></td></tr></table></figure><h2 id="只处理一部分字符">只处理一部分字符</h2><p>下标运算符<code>[]</code></p><ul><li><ul><li>接受输入参数<code>string::size_type</code> 类型的值</li></ul></li><li><ul><li>返回值 该位置上字符的引用</li></ul></li><li><ul><li>下标大于等于0 小于<code>s.size()</code></li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//stringIndex.cpp</span></span><br><span class="line"><span class="comment">//字符改大写</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::string;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::toupper;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="function">string <span class="title">s</span><span class="params">(<span class="string">&quot;some string&quot;</span>)</span></span>;</span><br><span class="line"><span class="keyword">if</span> (!s.<span class="built_in">empty</span>())</span><br><span class="line">cout &lt;&lt; s[<span class="number">0</span>] &lt;&lt; endl; <span class="comment">//s</span></span><br><span class="line"><span class="keyword">if</span> (!s.<span class="built_in">empty</span>())</span><br><span class="line">s[<span class="number">0</span>] = <span class="built_in">toupper</span>(s[<span class="number">0</span>]);</span><br><span class="line">cout &lt;&lt; s &lt;&lt; endl; <span class="comment">//Some string</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用下标进行迭代">使用下标进行迭代</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//stringIndex2.cpp</span></span><br><span class="line"><span class="comment">//首个单词字符改大写</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::string;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::toupper;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="function">string <span class="title">s</span><span class="params">(<span class="string">&quot;some string&quot;</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">decltype</span>(s.<span class="built_in">size</span>()) index = <span class="number">0</span>;</span><br><span class="line">        index != s.<span class="built_in">size</span>() &amp;&amp; !<span class="built_in">isspace</span>(s[index]); ++index) &#123;</span><br><span class="line">s[index] = <span class="built_in">toupper</span>(s[index]);</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; s &lt;&lt; endl;<span class="comment">//SOME string</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &amp;&amp; 逻辑与运算</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//stringIndex3.cpp 转16进制</span></span><br><span class="line"><span class="comment">//str[x],[]输入参数为string::size_type类型，给出int整型也会自动转化为该类型</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::cin;</span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstddef&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::<span class="type">size_t</span>;</span><br><span class="line"><span class="keyword">using</span> std::string;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">const</span> string hexdigits = <span class="string">&quot;0123456789ABCDEF&quot;</span>;  <span class="comment">// possible hex digits</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Enter a series of numbers between 0 and 15&quot;</span></span><br><span class="line">     &lt;&lt; <span class="string">&quot; separated by spaces.  Hit ENTER when finished: &quot;</span> &lt;&lt; endl;</span><br><span class="line">string result;        <span class="comment">// will hold the resulting hexify&#x27;d string</span></span><br><span class="line">string::size_type n;  <span class="comment">// hold numbers from the input</span></span><br><span class="line"><span class="keyword">while</span> (cin &gt;&gt; n)</span><br><span class="line"><span class="keyword">if</span> (n &lt; hexdigits.<span class="built_in">size</span>())    <span class="comment">// ignore invalid input</span></span><br><span class="line">result += hexdigits[n];  <span class="comment">// fetch the indicated hex digit</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Your hex number is: &quot;</span> &lt;&lt; result &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//编写一段程序，读入一个包含标点符号的字符串，将标点符号去除后输出字符串剩余的部分。</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::string;</span><br><span class="line"><span class="keyword">using</span> std::cin;</span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">string s = <span class="string">&quot;!!!hello world!!!&quot;</span>;</span><br><span class="line">string result;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> x : s) &#123;</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">ispunct</span>(x)) &#123;</span><br><span class="line">result += x;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; result &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="标准库类型-vector">标准库类型 vector</h1><p>vector是一个容器，也是一个类模板</p><ul><li><p>容器：包含其他对象。</p></li><li><p>类模板：本身不是类，但可以实例化出一个类。</p><ul><li>vector是一个模板，vector<int>是一个类型。</int></li></ul></li><li><p>类模板名字后面跟一对尖括号，在括号内放上信息来指定类型</p></li><li><ul><li>如vector<int> ivec</int></li><li>vector的元素还可以是vector</li><li><ul><li>如vector&lt;vector<int>&gt;</int></li><li>如vector&lt;vector<int> &gt; 过去的写法，需要加空格</int></li></ul></li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用vector必须包含适当的头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br></pre></td></tr></table></figure><h2 id="定义和初始化vector对象">定义和初始化vector对象</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;T&gt; v1;               <span class="comment">//v1是一个空vector，它潜在的元素是T类型的，执行默认初始化 </span></span><br><span class="line"><span class="function">vector&lt;T&gt; <span class="title">v2</span><span class="params">(v1)</span></span>;           <span class="comment">//v2中包含有v1所有元素的副本 </span></span><br><span class="line">vector&lt;T&gt; v2 = v1;          <span class="comment">//等价于v2(v1)，v2中包含v1所有元素的副本 </span></span><br><span class="line"><span class="function">vector&lt;T&gt; <span class="title">v3</span><span class="params">(n, val)</span></span>;       <span class="comment">// v3包含了n个重复的元素，每个元素的值都是val </span></span><br><span class="line"><span class="function">vector&lt;T&gt; <span class="title">v4</span><span class="params">(n)</span></span>;            <span class="comment">// v4包含了n个重复地执行了值初始化的对象 </span></span><br><span class="line">vector&lt;T&gt; v5&#123;a, b, c...&#125;;   <span class="comment">//v5包含了初始值个数的元素，每个元素被赋予相应的初始值 </span></span><br><span class="line">vector&lt;T&gt; v5=&#123;a, b, c...&#125;;  <span class="comment">//等价于v5&#123;a, b, c...&#125; </span></span><br><span class="line"></span><br><span class="line">- 默认初始化： vector&lt;string&gt; svec; <span class="comment">//svec 不含元素</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; ivec;           <span class="comment">//初始状态为空</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ivec2</span><span class="params">(ivec)</span></span>;    <span class="comment">//ivec 拷贝ivec2</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ivec3</span><span class="params">(ivec)</span></span>;    <span class="comment">//ivec 拷贝 ivec3</span></span><br><span class="line"><span class="function">vector&lt;string&gt; <span class="title">svec</span><span class="params">(ivec2)</span></span>; <span class="comment">//错误 string 不是int</span></span><br></pre></td></tr></table></figure><h2 id="列表初始化vector对象">列表初始化vector对象</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- 列表初始化：vector&lt;string&gt; v&#123;<span class="string">&quot;a&quot;</span>,<span class="string">&quot;an&quot;</span>,<span class="string">&quot;the&quot;</span>&#125;; (c++ <span class="number">11</span>)</span><br><span class="line">    - 使用<span class="string">&quot;=&quot;</span>只能提供一个初始值</span><br><span class="line">    - 类内初始值，只能用拷贝初始化或使用花括号形式初始化</span><br><span class="line">    - 提供初始值元素值列表，初始值放入花括号，进入列表初始化</span><br></pre></td></tr></table></figure><h2 id="创建指定数量的元素">创建指定数量的元素</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ivec</span><span class="params">(<span class="number">10</span>,<span class="number">-1</span>)</span></span>; <span class="comment">//10个int类型的元素，每个都被初始化为-1</span></span><br><span class="line"><span class="function">vector&lt;string&gt; <span class="title">svec</span><span class="params">(<span class="number">10</span>,<span class="string">&quot;hi!&quot;</span>)</span>  <span class="comment">//10个string类型的元素，每个都被初始化为&quot;hi!&quot;</span></span></span><br></pre></td></tr></table></figure><h2 id="值初始化">值初始化</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可以只提供vector对象容纳的元素数量而不用略去初始值</span></span><br><span class="line"><span class="comment">// 此时库会创建⼀个值初始化元素初值，赋给容器中所有元素</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ivec</span><span class="params">(<span class="number">10</span>)</span></span>; <span class="comment">//10个元素，每个都初始化为0</span></span><br><span class="line"><span class="function">vector&lt;string&gt; <span class="title">svec</span><span class="params">(<span class="number">10</span>)</span></span>; <span class="comment">//10个元素，每个都是空string对象</span></span><br><span class="line"><span class="comment">// 如果只提供元素数量而没有设定初始值，只能使用直接初始化</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; vi =<span class="number">10</span>; <span class="comment">//错误，必须使用直接初始化形式指定向量⼤⼩</span></span><br></pre></td></tr></table></figure><h2 id="列表按初始值-元素数量">列表按初始值 元素数量</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过花括号 圆括号区分</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v1</span><span class="params">(<span class="number">10</span>)</span></span>; <span class="comment">//v1有10个元素，每个值都是0</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v2&#123;<span class="number">10</span>&#125;; <span class="comment">//v2有1个元素，值为10</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v3</span><span class="params">(<span class="number">10</span>,<span class="number">1</span>)</span></span>; <span class="comment">//v3有10个元素，每个值为1</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v4&#123;<span class="number">10</span>,<span class="number">1</span>&#125;; <span class="comment">//v4有2个元素，值分别为10和1</span></span><br><span class="line"><span class="comment">//如果初始化使用了花括号的形式，但提供的值不能用来列表初始化，</span></span><br><span class="line"><span class="comment">//就要考虑用这样的值构造vector对象</span></span><br><span class="line">vector&lt;string&gt; v5&#123;<span class="string">&quot;hi&quot;</span>&#125;; <span class="comment">//列表初始化，v5有⼀个元素</span></span><br><span class="line"><span class="function">vector&lt;string&gt; <span class="title">v6</span><span class="params">(<span class="string">&quot;hi&quot;</span>)</span></span>; <span class="comment">//错误，不能使用字符串字面值构建vector对象</span></span><br><span class="line">vector&lt;string&gt; v7&#123;<span class="number">10</span>&#125;; <span class="comment">//v7有10个默认初始化元素</span></span><br><span class="line">vector&lt;string&gt; v8&#123;<span class="number">10</span>,<span class="string">&quot;hi&quot;</span>&#125;; <span class="comment">//v8有10个值为&quot;hi&quot;的元素</span></span><br></pre></td></tr></table></figure><p>练习：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//下列的vector对象各包含多少个元素？这些元素的值分别是多少？</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v1; <span class="comment">// size:0, no values.</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v2</span><span class="params">(<span class="number">10</span>)</span></span>; <span class="comment">// size:10, value:0</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v3</span><span class="params">(<span class="number">10</span>, <span class="number">42</span>)</span></span>; <span class="comment">// size:10, value:42</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v4&#123; <span class="number">10</span> &#125;; <span class="comment">// size:1, value:10</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v5&#123; <span class="number">10</span>, <span class="number">42</span> &#125;; <span class="comment">// size:2, value:10, 42</span></span><br><span class="line">vector&lt;string&gt; v6&#123; <span class="number">10</span> &#125;; <span class="comment">// size:10, value:&quot;&quot;</span></span><br><span class="line">vector&lt;string&gt; v7&#123; <span class="number">10</span>,<span class="string">&quot;hi&quot;</span> &#125;; <span class="comment">// size:10, value:&quot;hi&quot;</span></span><br></pre></td></tr></table></figure><h2 id="向vector对象中添加元素">向vector对象中添加元素</h2><h3 id="v.push_back-在尾部添加元素">v.push_back() 在尾部添加元素</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v2;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i!=<span class="number">100</span>;i++)&#123;</span><br><span class="line">    v2.<span class="built_in">push_back</span>(i);</span><br><span class="line">&#125; <span class="comment">//循环结束后v2有100个元素，0-11</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//从标准输入中读取单词，将其作为vector对象的元素存储</span></span><br><span class="line">string word;</span><br><span class="line">vector&lt;string&gt; text;</span><br><span class="line"><span class="keyword">while</span>(cin&gt;&gt;word)&#123;</span><br><span class="line">    text.<span class="built_in">push_back</span>(word); <span class="comment">//把word添加到text后面</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>vector对象可高速增长</li><li>范围for语句不应改变其所遍历序列的大小</li></ul><p>练习：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//编写⼀段程序，⽤cin读⼊⼀组整数并把它们存⼊⼀个vector对象。</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::cin;<span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;<span class="keyword">using</span> std::vector;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">while</span> (cin &gt;&gt; i)</span><br><span class="line">&#123;</span><br><span class="line">v.<span class="built_in">push_back</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//改写上题程序，不过这次读⼊的是字符串。</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::cin;<span class="keyword">using</span> std::cout;<span class="keyword">using</span> std::endl;</span><br><span class="line"><span class="keyword">using</span> std::vector;<span class="keyword">using</span> std::string;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;string&gt; v;</span><br><span class="line">    string i;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; i)</span><br><span class="line">    &#123;</span><br><span class="line">        v.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="其他vector操作">其他vector操作</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">v.<span class="built_in">empty</span>()  <span class="comment">//如果v不含任何元素，返回真，否则假</span></span><br><span class="line">v.<span class="built_in">size</span>()  <span class="comment">//返回v中元素的个数</span></span><br><span class="line">v.<span class="built_in">push_back</span>()  <span class="comment">//向v的尾端添加一个值为t的元素</span></span><br><span class="line">v[n]  <span class="comment">//返回v中第n个位置元素的引用</span></span><br><span class="line">v1 = v2 <span class="comment">//用v2中的元素拷贝替换v1中的元素</span></span><br><span class="line">v1 = &#123;a,b,c,.....&#125; <span class="comment">//用列表中的元素拷贝替换v1中的元素</span></span><br><span class="line">v1 == v2 <span class="comment">//v1和v2相等当且仅当它们的元素数量相同且对应位置的元素值都相同</span></span><br><span class="line">v1 != v2 <span class="comment">//同上</span></span><br><span class="line">&lt; , &lt;= , &gt; , &gt;=  <span class="comment">//按照字典顺序进行比较</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//size_type需要指定由那种类型定义</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; ::size_type  <span class="comment">//正确</span></span><br><span class="line">vector::size_type  <span class="comment">//错误</span></span><br></pre></td></tr></table></figure><h3 id="不能用下表形式添加元素">不能用下表形式添加元素</h3><ul><li>vector对象(以及string对象)的下标运算符，只能对确知已存在的元素执行下标操作，不能用于添加元素。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//读如一组整数并把他们存入一个vector对象，将每对相邻整数的和输出出来。</span></span><br><span class="line"><span class="comment">//改写你的程序，这次要求先输出第一个和最后一个元素的和，</span></span><br><span class="line"><span class="comment">//接着输出第二个和倒数第二个元素的和，以此类推。</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::cin;</span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"><span class="keyword">using</span> std::string;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; ivec;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">while</span> (cin &gt;&gt; i) &#123;</span><br><span class="line">ivec.<span class="built_in">push_back</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">int</span>(ivec.<span class="built_in">size</span>()) - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">cout &lt;&lt; ivec[i] + ivec[i + <span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;---------------------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="type">int</span> m = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> n = ivec.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (m &lt; n) &#123;</span><br><span class="line">cout &lt;&lt; ivec[m] + ivec[n] &lt;&lt; endl;</span><br><span class="line">++m;</span><br><span class="line">--n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="迭代器介绍">迭代器介绍</h1><ul><li>所有标准库容器都可以使用迭代器</li><li>类似于指针类型，迭代器也提供了对对象的间接访问</li></ul><h2 id="使用迭代器">使用迭代器</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator iter</span><br><span class="line"><span class="keyword">auto</span> b = v.<span class="built_in">begin</span>(); <span class="comment">//返回指向第一个元素的迭代器</span></span><br><span class="line"><span class="keyword">auto</span> e = v.<span class="built_in">end</span>(); <span class="comment">//返回指向最后一个元素的下一个迭代器</span></span><br></pre></td></tr></table></figure><ul><li>如果容器为空，begin()和end()返回的是同一个迭代器，都是尾后迭代器。</li><li>使用解引用符*访问迭代器指向的元素。</li><li>容器：可以包含其他对象，但所有的对象必须类型相同。</li></ul><p>迭代器(iterator)：每种标准容器都有自己的迭代器。C++更倾向于迭代器而不是下表遍历。</p><h3 id="标准容器迭代器的运算符">标准容器迭代器的运算符</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">*iter  <span class="comment">//返回迭代器iter所指向的元素的引用</span></span><br><span class="line">iter-&gt;num  <span class="comment">//等价于(*iter).num</span></span><br><span class="line">++iter  <span class="comment">//令iter指向容器中的下一个元素</span></span><br><span class="line">--iter  <span class="comment">//令iter指向容器中的上一个元素</span></span><br><span class="line">iter1 == iter2  <span class="comment">//判断两个迭代器是否相等</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//首字符改大写</span></span><br><span class="line"><span class="function">string <span class="title">s</span><span class="params">(<span class="string">&quot;some string&quot;</span>)</span></span>;</span><br><span class="line"><span class="keyword">if</span>(s.<span class="built_in">begin</span>()!=s.<span class="built_in">end</span>())&#123;</span><br><span class="line">    <span class="keyword">auto</span> it = s.<span class="built_in">begin</span>();</span><br><span class="line">    *it = <span class="built_in">toupper</span>(*it);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Some string</span></span><br></pre></td></tr></table></figure><h3 id="将迭代器从一个元素移动到另一个元素">将迭代器从一个元素移动到另一个元素</h3><ul><li>使用++运算符</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//首字母改大写</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> it = s.<span class="built_in">begin</span>();</span><br><span class="line">    it != s.<span class="built_in">end</span>() &amp;&amp; !<span class="built_in">isspace</span>(*it); ++it )</span><br><span class="line">    *it = <span class="built_in">toupper</span>(*it);</span><br></pre></td></tr></table></figure><ul><li>使用迭代器和!=</li><li>所有的标准库迭代器都定义了==和!=</li></ul><h2 id="迭代器类型">迭代器类型</h2><ul><li>一般来说无需知道迭代器精确类型</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator it;  <span class="comment">//it可读写元素</span></span><br><span class="line">string::iterator it2;  <span class="comment">//it2可读写字符</span></span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::const_iterator it3;  <span class="comment">//it3只可读元素，不可改写元素</span></span><br><span class="line">string::const_iterator it4;  <span class="comment">//it4只可读字符，不能改写字符</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//const_iterator和常量指针差不多，iterator的对象可读可写</span></span><br><span class="line"><span class="comment">//如果vector或string是常量，只能用const_iterator</span></span><br></pre></td></tr></table></figure><h2 id="beginend-运算符">begin，end 运算符</h2><ul><li>返回的具体类型是由对象是否是常量从而决定是否是const_iterator还是iterator</li><li>为了便于得到const_iterator返回值，C++引入<code>cbegin</code>，<code>cend</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> it3 = v.<span class="built_in">cbegin</span>();  <span class="comment">//类型是vector&lt;int&gt;::const_iterator</span></span><br></pre></td></tr></table></figure><h2 id="解引用和成员访问操作">解引用和成员访问操作</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(*it).<span class="built_in">empty</span>();  <span class="comment">//解引用it，调用结果对象的empty成员</span></span><br><span class="line">*it.empty; <span class="comment">//错误，没考虑运算符优先级，试图访问it的empty成员</span></span><br><span class="line">           <span class="comment">//it是一个迭代器，无empty成员</span></span><br><span class="line"><span class="comment">//箭头运算符-&gt;把解引用和成员访问两个操作结合起来在一起。</span></span><br><span class="line"><span class="comment">//it-&gt;num 和 (*it).num意义相同</span></span><br><span class="line"><span class="comment">//循环遍历text，知道遇到空字符串为止</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> it = text.<span class="built_in">cbegin</span>();</span><br><span class="line">     it!=text.<span class="built_in">cend</span>() &amp;&amp; !it-&gt;<span class="built_in">empty</span>(); ++it)</span><br><span class="line">    cout&lt;&lt;*it&lt;&lt;endl;</span><br></pre></td></tr></table></figure><ul><li>谨记：但凡是使用了迭代器的循环体，都不要向迭代器所属的容器添加元素。</li><li>会使迭代器失效</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//编写一段程序，创建一个含有10个整数的vector对象，</span></span><br><span class="line"><span class="comment">//然后使用迭代器将所有元素的值都变成原来的两倍。</span></span><br><span class="line"><span class="comment">//输出vector对象的内容，检验程序是否正确。</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(<span class="number">10</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">*it *= <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> one : v) &#123;</span><br><span class="line">cout &lt;&lt; one &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="迭代器运算">迭代器运算</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">vector和string迭代器支持的运算：</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">iter + n 迭代器加上⼀个整数值仍得到⼀个迭代器，</span></span><br><span class="line"><span class="comment">迭代器指示的新位置和原来相比向前移动了若干个元素。</span></span><br><span class="line"><span class="comment">结果迭代器或者指示容器内的⼀个元素，</span></span><br><span class="line"><span class="comment">或者指示容器尾元素的下⼀位置。</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">iter - n 迭代器减去⼀个整数值仍得到⼀个迭代器，</span></span><br><span class="line"><span class="comment">迭代器指示的新位置比原来向后移动了若干个元素。</span></span><br><span class="line"><span class="comment">结果迭代器或者指向容器内的⼀个元素，</span></span><br><span class="line"><span class="comment">或者指示容器尾元素的下⼀位置。</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">iter1 += n 迭代器加法的复合赋值语句，将iter1加n的结果赋给iter1</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">iter1 -= n 迭代器减法的复合赋值语句，将iter2减n的结果赋给iter1</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">iter1 - iter2 两个迭代器相减的结果是它们之间的距离，也就是说，</span></span><br><span class="line"><span class="comment">将运算符右侧的迭代器向前移动差值个元素后得到左侧的迭代器。</span></span><br><span class="line"><span class="comment">参与运算的两个迭代器必须指向的是同⼀个容器中的元素</span></span><br><span class="line"><span class="comment">或者尾元素的下⼀位置。</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">&gt;、&gt;=、&lt;、&lt;= 迭代器的关系运算符，如果某迭代器</span></span><br><span class="line"><span class="comment">difference_type 保证足够大以存储任何两个迭代器对象间的距离，可正可负。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="使用迭代器运算-二分搜索">使用迭代器运算 二分搜索</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//biSearch.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::string;</span><br><span class="line"><span class="keyword">using</span> std::iterator;</span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">string text = <span class="string">&quot;abcdefghi&quot;</span>;</span><br><span class="line">cout &lt;&lt; text &lt;&lt; endl;</span><br><span class="line"><span class="keyword">auto</span> beg = text.<span class="built_in">begin</span>(), end = text.<span class="built_in">end</span>();</span><br><span class="line"><span class="keyword">auto</span> mid = beg + (end - beg) / <span class="number">2</span>;</span><br><span class="line"><span class="type">char</span> sought = <span class="string">&#x27;c&#x27;</span>;</span><br><span class="line"><span class="keyword">while</span> (mid != end &amp;&amp; *mid != sought) &#123;</span><br><span class="line"><span class="keyword">if</span> (sought &lt; *mid) end = mid;</span><br><span class="line"><span class="keyword">else</span> beg = mid + <span class="number">1</span>;</span><br><span class="line">mid = beg + (end - beg) / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (*mid == sought) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;found:&quot;</span> &lt;&lt; *mid &lt;&lt; <span class="string">&quot;@&quot;</span> &lt;&lt; mid - text.<span class="built_in">begin</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//abcdefghi</span></span><br><span class="line"><span class="comment">//found:c@2</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//biSearch2.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::string;</span><br><span class="line"><span class="keyword">using</span> std::iterator;</span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">vector&lt;string&gt; text&#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;ab&quot;</span>, <span class="string">&quot;abc&quot;</span>, <span class="string">&quot;abcd&quot;</span>, <span class="string">&quot;abcdefghi&quot;</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> s : text)</span><br><span class="line">cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line"><span class="keyword">auto</span> beg = text.<span class="built_in">begin</span>(), end = text.<span class="built_in">end</span>();</span><br><span class="line"><span class="keyword">auto</span> mid = beg + (end - beg) / <span class="number">2</span>;</span><br><span class="line">string sought = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="keyword">while</span> (mid != end &amp;&amp; *mid != sought) &#123;</span><br><span class="line"><span class="keyword">if</span> (sought &lt; *mid) end = mid;</span><br><span class="line"><span class="keyword">else</span> beg = mid + <span class="number">1</span>;</span><br><span class="line">mid = beg + (end - beg) / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (*mid == sought) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;found:&quot;</span> &lt;&lt; *mid &lt;&lt; <span class="string">&quot;@&quot;</span> &lt;&lt; mid - text.<span class="built_in">begin</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//a</span></span><br><span class="line"><span class="comment">//ab</span></span><br><span class="line"><span class="comment">//abc</span></span><br><span class="line"><span class="comment">//abcd</span></span><br><span class="line"><span class="comment">//abcdefghi</span></span><br><span class="line"><span class="comment">//found:abc@2</span></span><br></pre></td></tr></table></figure><p>练习：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//划分分数段的程序是使用下标运算符实现的，请利用迭代器改写该程序实现完全相同的功能</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::cin;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="function">vector&lt;<span class="type">unsigned</span>&gt; <span class="title">scores</span><span class="params">(<span class="number">11</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="type">unsigned</span> grade;</span><br><span class="line"><span class="keyword">while</span> (cin &gt;&gt; grade) &#123;</span><br><span class="line"><span class="keyword">if</span> (grade &lt;= <span class="number">100</span>)</span><br><span class="line">++*(scores.<span class="built_in">begin</span>() + grade / <span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> s : scores)</span><br><span class="line">cout &lt;&lt; s &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在二分搜索程序中，为什么用的是 mid = beg + (end - beg) / 2</span></span><br><span class="line"><span class="comment">//而非 mid = (beg + end) / 2  ?</span></span><br><span class="line">因为两个迭代器相互之间支持的运算只有 - ，⽽没有 + 。</span><br><span class="line">但是迭代器和迭代器差值（整数值）之间支持 +。</span><br></pre></td></tr></table></figure><h1 id="数组">数组</h1><ul><li>存放相同对象的容器，数组大小固定。</li><li>如果不清楚元素确切个数，请使用vector</li></ul><h2 id="定义和初始化内置数组">定义和初始化内置数组</h2><ul><li>形如a[d]，a是数组名，d是数组为度，是常量表达式</li><li>长度必须是constexpr表达式</li><li>数组不允许直接复制给另一个数组</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> cnt = <span class="number">42</span>;  <span class="comment">//不是常量表达式</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">unsigned</span> sz = <span class="number">3</span>; <span class="comment">//常量表达式</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> *parr[sz];  <span class="comment">//ok</span></span><br><span class="line">string bad[cnt];  <span class="comment">//错误，不是常量表达式</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//显式初始化</span></span><br><span class="line"><span class="type">int</span> a[] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="type">int</span> b[sz] = &#123;<span class="number">0</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;</span><br></pre></td></tr></table></figure><h3 id="字符数组特性">字符数组特性</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> a3[] = <span class="string">&quot;cpp&quot;</span> ;  <span class="comment">//自动添加&quot;\0&quot;空字符</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> a4[<span class="number">6</span>] = <span class="string">&quot;daniel&quot;</span>; <span class="comment">//错误，空间不够大，&quot;\0&quot;放不下</span></span><br></pre></td></tr></table></figure><h2 id="不允许拷贝和赋值">不允许拷贝和赋值</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[] = &#123;<span class="number">0</span>, <span class="number">2</span>, <span class="number">2</span>&#125;;</span><br><span class="line"><span class="type">int</span> a2[] = a;<span class="comment">//错误，不允许</span></span><br><span class="line">a2 = a;<span class="comment">//错误，不能直接赋值；</span></span><br></pre></td></tr></table></figure><h2 id="复杂的数组声明">复杂的数组声明</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *ptrs[<span class="number">10</span>];  <span class="comment">//数组，存10个int*指针</span></span><br><span class="line"><span class="type">int</span> &amp;p1[<span class="number">10</span>] = ...;  <span class="comment">//错误 不存在引用数组</span></span><br><span class="line"><span class="built_in">int</span> (*Parray)[<span class="number">10</span>]=&amp;arr;  <span class="comment">//Parray指向⼀个含有10个整数的数组</span></span><br><span class="line"><span class="built_in">int</span> (&amp;arrRef)[<span class="number">10</span>]=arr;  <span class="comment">//arrRef引用⼀个含有10个整数的数组</span></span><br><span class="line"><span class="type">int</span> *(&amp;arry)[<span class="number">10</span>]=ptrs;  <span class="comment">//arry是数组的引用，该数组含有10个指针</span></span><br><span class="line"><span class="comment">//从数组名开始，由内向外阅读</span></span><br></pre></td></tr></table></figure><h2 id="访问数组元素">访问数组元素</h2><ul><li><p>数组下表的类型：size_t ，头文件是cstddef</p></li><li><p>字符数组的特殊性，结尾处有一个看空白字符，如：</p><pre><code>   + char a[] = “hello”;</code></pre></li><li><p>用数组初始化vector：</p><pre><code>  + int a[] = &#123;1, 2, 3, 4, 5&#125;;  + vector v(begin(a), end(a));</code></pre></li></ul><h2 id="数组和指针">数组和指针</h2><ul><li>使用数组时，编译器⼀般会把它转换成指针。</li><li><strong>指针访问数组</strong>：在表达式中使用数组名时，名字会自动转换成指向数组的第⼀个元素的指针。</li><li>标准库函数 <code>begin</code>,<code>end</code>。<code>begin(ia)</code>,<code>end(ia)</code><ul><li>int ia[]={1,2,3};</li><li>auto n = end(ia) - begin(ia);//n为元素数量内置下标运算符所用的索引不是无符号数</li></ul></li></ul><h2 id="c风格字符串">C风格字符串</h2><ul><li>从c继承来的字符串</li><li>以空字符\0结束</li><li>对大多数应用来说，使用标准库string比使用c风格字符串更安全，更高效。</li><li>获取string中的cstring：<ul><li>const char *str = s.c_str();</li></ul></li></ul><p>C标准库string函数，定义在<cstring>中：</cstring></p><table><colgroup><col style="width: 18%"><col style="width: 81%"></colgroup><thead><tr class="header"><th style="text-align: center;">函数</th><th style="text-align: left;">说明</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">strlen(p)</td><td style="text-align: left;">返回p的长度，空字符不计算在内</td></tr><tr class="even"><td style="text-align: center;">strcmp(p1, p2)</td><td style="text-align: left;">比较p1和p2的相等性。p1==p2，返回0；p1&gt;p2，返回一个正值；p1&lt;p2，返回一个负值。</td></tr><tr class="odd"><td style="text-align: center;">strcat(p1, p2)</td><td style="text-align: left;">将p2附加到p1之后，返回p1</td></tr><tr class="even"><td style="text-align: center;">strcpy(p1, p2)</td><td style="text-align: left;">将p2拷贝到p1，返回p1</td></tr></tbody></table><h1 id="多维数组">多维数组</h1><ul><li>严格来说C++没有多维数组</li><li>多维数组其实是数组的数组</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ia[<span class="number">3</span>][<span class="number">4</span>];<span class="comment">//3⾏4列数组</span></span><br><span class="line"><span class="type">int</span> arr[<span class="number">10</span>][<span class="number">20</span>][<span class="number">30</span>] = &#123;<span class="number">0</span>&#125;;<span class="comment">//所有元素初始化为0</span></span><br></pre></td></tr></table></figure><h2 id="多维数组的初始化">多维数组的初始化</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ia[<span class="number">3</span>][<span class="number">4</span>] = &#123;</span><br><span class="line">  &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,</span><br><span class="line">  &#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;,</span><br><span class="line">  &#123;<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> ia[<span class="number">3</span>][<span class="number">4</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>&#125;;</span><br><span class="line"><span class="type">int</span> ia[<span class="number">3</span>][<span class="number">4</span>]=&#123;&#123;<span class="number">0</span>&#125;,&#123;<span class="number">4</span>&#125;,&#123;<span class="number">8</span>&#125;&#125;;<span class="comment">//初始化每行首个元素</span></span><br><span class="line"><span class="type">int</span> ix[<span class="number">3</span>][<span class="number">4</span>]=&#123;<span class="number">0</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">9</span>&#125;;<span class="comment">//显示初始化第1行，其它初始化为0</span></span><br></pre></td></tr></table></figure><h2 id="多维数组的下标引用">多维数组的下标引用</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- 表达式的下标运算符和数组维度⼀样多，结果是给定类型元素</span><br><span class="line">- 表达式的下标运算符数量⼩于数组维度，结果是给定索引处的内层数组</span><br><span class="line"><span class="comment">//用arr首元素为ia最后一行最后一个元素赋值</span></span><br><span class="line">ia[<span class="number">2</span>][<span class="number">3</span>] = arr[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line"><span class="built_in">int</span> (&amp;row)[<span class="number">4</span>] = ia[<span class="number">1</span>];  <span class="comment">//把row绑定到ia第二个4元素数组上</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//两层嵌套for循环处理多维数组元素</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">size_t</span> rowCnt=<span class="number">3</span>,colCnt=<span class="number">4</span>;</span><br><span class="line"><span class="type">int</span> ia[rowCnt][colCnt];<span class="comment">//12个未初始化元素</span></span><br><span class="line">  <span class="comment">//对于每一行</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">size_t</span> i=<span class="number">0</span>;i!=rowCnt;++i)&#123;</span><br><span class="line">  <span class="comment">//对于行内每⼀列</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">size_t</span> j=<span class="number">0</span>;j!=colCnt;++j)&#123;</span><br><span class="line">  <span class="comment">//将元素位置索引作为值</span></span><br><span class="line">      ia[i][j]=i*colCnt+j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用范围for语句处理多维数组">使用范围for语句处理多维数组</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//c++11新标准</span></span><br><span class="line"><span class="type">size_t</span> cnt=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> &amp;row:ia)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> &amp;col:row)&#123;</span><br><span class="line">col=cnt;</span><br><span class="line">++cnt;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//能编译通过</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span> &amp;row:ia)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> col:row)&#123;</span><br><span class="line">cout&lt;&lt;col&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//不能编译通过</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> row:ia)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> col:row)&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//row的类型是int*，内层循环将不合法</span></span><br></pre></td></tr></table></figure><ul><li>使用范围for语句时，除了最内层的循环外，其他所有循环的控制变量都应该是引用类型。</li></ul><h2 id="指针和多维数组">指针和多维数组</h2><ul><li>程序使用多维数组名字，自动转为指向数组首元素的指针</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//多维数组实际是数组的数组</span></span><br><span class="line"><span class="type">int</span> ia[<span class="number">3</span>][<span class="number">4</span>];</span><br><span class="line"><span class="built_in">int</span> (*p)[<span class="number">4</span>]=ia; <span class="comment">//p指向含有4个整数的数组</span></span><br><span class="line">p=&amp;ia[<span class="number">2</span>]; <span class="comment">//p指向ia的尾元素</span></span><br><span class="line"><span class="comment">//圆括号不可少</span></span><br><span class="line"><span class="type">int</span> *ip[<span class="number">4</span>]; <span class="comment">//整型指针的数组</span></span><br></pre></td></tr></table></figure><ul><li>使用auto或decltype，能尽可能避免在数组前加指针类型</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//输出ia中每个元素的值</span></span><br><span class="line"><span class="comment">//p 指向含有4个整数的数组</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> p=ia;p!=ia+<span class="number">3</span>;++p)&#123;</span><br><span class="line">   <span class="comment">//q指向4个整数数组的⾸元素，也就是说，q指向⼀个整数</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> q=*p;q!=*p+<span class="number">4</span>;++q)</span><br><span class="line">cout&lt;&lt;*q&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用标准库函数begin， end更简洁</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//p指向ia的第⼀个数组</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> p=<span class="built_in">begin</span>(ia);p!=<span class="built_in">end</span>(ia);++p)&#123;</span><br><span class="line"><span class="comment">//q指向内层数组首元素</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> q=<span class="built_in">begin</span>(*p);q!=<span class="built_in">end</span>(*p);++q)&#123;</span><br><span class="line">cout&lt;&lt;*q&lt;&lt;<span class="string">&#x27; &#x27;</span>;<span class="comment">//输出q所指的整数值</span></span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使⽤auto关键字 不再烦⼼类型是什么</span></span><br></pre></td></tr></table></figure><h2 id="类型别名简化多维数组的指针">类型别名简化多维数组的指针</h2><ul><li>使用类型别名，让读写一个指向多维数组的指针变得简单一点</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> int_array = <span class="type">int</span>[<span class="number">4</span>];<span class="comment">//c++11新标准 类型别名的声明</span></span><br><span class="line">tpyedef <span class="type">int</span> int_array[<span class="number">4</span>];<span class="comment">//等价的typedef声明</span></span><br><span class="line"><span class="comment">//输出ia中每个元素的值 每个内层数组各占一行</span></span><br><span class="line"><span class="keyword">for</span>(int_array *p=ia;p!=ia+<span class="number">3</span>;++p)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> *q=*p;q!=*p+<span class="number">4</span>;++q)&#123;</span><br><span class="line">cout&lt;&lt;*q&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//⽤int_array定义外层循环控制变量，让程序简明</span></span><br></pre></td></tr></table></figure><p>练习：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//分别使用for语句、下标运算符、指针，输出二维数组元素。直接写出数据类型。</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> arr[<span class="number">3</span>][<span class="number">4</span>] = &#123;</span><br><span class="line">&#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;,</span><br><span class="line">&#123; <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span> &#125;,</span><br><span class="line">&#123; <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// range for</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="built_in">int</span>(&amp;row)[<span class="number">4</span>] : arr)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> col : row)</span><br><span class="line">cout &lt;&lt; col &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="comment">// for loop</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i != <span class="number">3</span>; ++i)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> j = <span class="number">0</span>; j != <span class="number">4</span>; ++j) cout &lt;&lt; arr[i][j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="comment">// using pointers.</span></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span>(*row)[<span class="number">4</span>] = arr; row != arr + <span class="number">3</span>; ++row)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> *col = *row; col != *row + <span class="number">4</span>; ++col) cout &lt;&lt; *col &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;命名空间的using声明&quot;&gt;命名空间的using声明&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;使用某个命名空间：例如&lt;code&gt;using std::cin&lt;/code&gt;表示使用命名空间&lt;code&gt;std&lt;/code&gt;中的名字&lt;code&gt;cin&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//using1.cpp&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// using 声明，当我们使用cin时，从命名空间std中获取&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;using&lt;/span&gt; std::cin;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; i;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	cin &amp;gt;&amp;gt; i;&lt;span class=&quot;comment&quot;&gt;//正确 cin和std::cin含义相同&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;// cout &amp;lt;&amp;lt; i; //错误 没有对应的using声明，必须使用完整的名字&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//[Error] &amp;#x27;cout&amp;#x27; was not declared in this scope; did you mean &amp;#x27;std::cout&amp;#x27;?&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	std::cout &amp;lt;&amp;lt; i; &lt;span class=&quot;comment&quot;&gt;//正确 显示地从std中使用cout&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;每个名字都需要独立的USING声明&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//using2.cpp&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// using declarations for names from the standard library&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;using&lt;/span&gt; std::cin;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;using&lt;/span&gt; std::cout;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;using&lt;/span&gt; std::endl;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	cout &amp;lt;&amp;lt; &lt;span class=&quot;string&quot;&gt;&amp;quot;Enter two numbers:&amp;quot;&lt;/span&gt; &amp;lt;&amp;lt; endl;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; v1, v2;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	cin &amp;gt;&amp;gt; v1 &amp;gt;&amp;gt; v2;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	cout &amp;lt;&amp;lt; &lt;span class=&quot;string&quot;&gt;&amp;quot;The sum of &amp;quot;&lt;/span&gt; &amp;lt;&amp;lt; v1 &amp;lt;&amp;lt; &lt;span class=&quot;string&quot;&gt;&amp;quot; and &amp;quot;&lt;/span&gt; &amp;lt;&amp;lt; v2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	     &amp;lt;&amp;lt; &lt;span class=&quot;string&quot;&gt;&amp;quot; is &amp;quot;&lt;/span&gt; &amp;lt;&amp;lt; v1 + v2 &amp;lt;&amp;lt; endl;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="后端" scheme="http://lgq007.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="C++" scheme="http://lgq007.github.io/tags/C/"/>
    
    <category term="C" scheme="http://lgq007.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++ 入门-1</title>
    <link href="http://lgq007.github.io/2023/08/03/C++%20%E5%85%A5%E9%97%A8-1/"/>
    <id>http://lgq007.github.io/2023/08/03/C++%20%E5%85%A5%E9%97%A8-1/</id>
    <published>2023-08-02T16:04:06.000Z</published>
    <updated>2023-08-02T16:07:40.146Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本内置类型">基本内置类型</h1><blockquote><p>不同的编译器和平台可能会有差异,下表为在Windows_X64环境下使用MinGw GCC9.2.0 32_bit为例:</p></blockquote><table><thead><tr class="header"><th style="text-align: center;">类型</th><th style="text-align: center;">含义</th><th style="text-align: center;">最小尺寸</th><th style="text-align: center;">范围</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">bool</td><td style="text-align: center;">布尔类型</td><td style="text-align: center;">8bits</td><td style="text-align: center;">true或false</td></tr><tr class="even"><td style="text-align: center;">char</td><td style="text-align: center;">字符型</td><td style="text-align: center;">8bits</td><td style="text-align: center;">-2^7 ~ 2^7-1</td></tr><tr class="odd"><td style="text-align: center;">wchar_t</td><td style="text-align: center;">宽字符</td><td style="text-align: center;">16bits</td><td style="text-align: center;">0 ~ 2^16 - 1</td></tr><tr class="even"><td style="text-align: center;">char16_t</td><td style="text-align: center;">Unicode字符</td><td style="text-align: center;">16bits</td><td style="text-align: center;">0 ~ 2^16 - 1</td></tr><tr class="odd"><td style="text-align: center;">char32_t</td><td style="text-align: center;">Unicode字符</td><td style="text-align: center;">32bits</td><td style="text-align: center;">0 ~ 2^32 - 1</td></tr><tr class="even"><td style="text-align: center;">short</td><td style="text-align: center;">短整型</td><td style="text-align: center;">16bits</td><td style="text-align: center;">-2^15 ~ 2^15-1</td></tr><tr class="odd"><td style="text-align: center;">int</td><td style="text-align: center;">整型</td><td style="text-align: center;">32bits</td><td style="text-align: center;">-2^31 ~ 2^31-1</td></tr><tr class="even"><td style="text-align: center;">long</td><td style="text-align: center;">长整型</td><td style="text-align: center;">32bits</td><td style="text-align: center;">-2^31 ~ 2^31-1</td></tr><tr class="odd"><td style="text-align: center;">long long</td><td style="text-align: center;">长整型</td><td style="text-align: center;">64bits</td><td style="text-align: center;">-2^63 ~ 2^63-1</td></tr><tr class="even"><td style="text-align: center;">float</td><td style="text-align: center;">单精度浮点型</td><td style="text-align: center;">32bits</td><td style="text-align: center;">大约7位有效数字</td></tr><tr class="odd"><td style="text-align: center;">double</td><td style="text-align: center;">双精度浮点型</td><td style="text-align: center;">64bits</td><td style="text-align: center;">大约15位有效数字</td></tr><tr class="even"><td style="text-align: center;">long double</td><td style="text-align: center;">扩展精度浮点型</td><td style="text-align: center;">96bits</td><td style="text-align: center;">更高的有效数字</td></tr></tbody></table><span id="more"></span><p>可以在IDE中编译运行以下代码查看本机算数类型的尺寸</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Windows_X64环境下MinGw GCC 9.2.0 32_bit为例</span></span><br><span class="line"><span class="comment">// 1Byte = 8bit</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  cout&lt;&lt; <span class="string">&quot;int * &quot;</span>&lt;&lt;<span class="built_in">sizeof</span>(<span class="type">int</span>*)*<span class="number">8</span>&lt;&lt;endl; <span class="comment">// 32 bits</span></span><br><span class="line">  cout&lt;&lt; <span class="string">&quot;bool &quot;</span>&lt;&lt;<span class="built_in">sizeof</span>(<span class="type">bool</span>)*<span class="number">8</span>&lt;&lt;endl;  <span class="comment">// 8 bits</span></span><br><span class="line">  cout&lt;&lt; <span class="string">&quot;char &quot;</span>&lt;&lt;<span class="built_in">sizeof</span>(<span class="type">char</span>)*<span class="number">8</span>&lt;&lt;endl;  <span class="comment">// 8bits</span></span><br><span class="line">  cout&lt;&lt; <span class="string">&quot;wchar_t &quot;</span>&lt;&lt;<span class="built_in">sizeof</span>(<span class="type">wchar_t</span>)*<span class="number">8</span>&lt;&lt;endl;  <span class="comment">// 16bits</span></span><br><span class="line">  cout&lt;&lt; <span class="string">&quot;char16_t &quot;</span>&lt;&lt;<span class="built_in">sizeof</span>(<span class="type">char16_t</span> )*<span class="number">8</span>&lt;&lt;endl;  <span class="comment">// 16bits</span></span><br><span class="line">  cout&lt;&lt; <span class="string">&quot;char32_t &quot;</span>&lt;&lt;<span class="built_in">sizeof</span>(<span class="type">char32_t</span> )*<span class="number">8</span>&lt;&lt;endl;  <span class="comment">// 32bits</span></span><br><span class="line">  cout&lt;&lt; <span class="string">&quot;short &quot;</span>&lt;&lt;<span class="built_in">sizeof</span>(<span class="type">short</span> )*<span class="number">8</span>&lt;&lt;endl;  <span class="comment">// 16bits</span></span><br><span class="line">  cout&lt;&lt; <span class="string">&quot;int &quot;</span>&lt;&lt;<span class="built_in">sizeof</span>(<span class="type">int</span> )*<span class="number">8</span>&lt;&lt;endl;  <span class="comment">// 32bits</span></span><br><span class="line">  cout&lt;&lt; <span class="string">&quot;long &quot;</span>&lt;&lt;<span class="built_in">sizeof</span>(<span class="type">long</span> )*<span class="number">8</span>&lt;&lt;endl;  <span class="comment">// 32bits</span></span><br><span class="line">  cout&lt;&lt; <span class="string">&quot;long long&quot;</span>&lt;&lt;<span class="built_in">sizeof</span>(<span class="type">long</span> <span class="type">long</span>)*<span class="number">8</span>&lt;&lt;endl;  <span class="comment">// 64bits</span></span><br><span class="line">  cout&lt;&lt; <span class="string">&quot;float &quot;</span>&lt;&lt;<span class="built_in">sizeof</span>(<span class="type">float</span>)*<span class="number">8</span>&lt;&lt;endl;  <span class="comment">// 32bits</span></span><br><span class="line">  cout&lt;&lt; <span class="string">&quot;double &quot;</span>&lt;&lt;<span class="built_in">sizeof</span>(<span class="type">double</span>)*<span class="number">8</span>&lt;&lt;endl; <span class="comment">// 64bits</span></span><br><span class="line">  cout&lt;&lt; <span class="string">&quot;long double &quot;</span>&lt;&lt;<span class="built_in">sizeof</span>(<span class="type">long</span> <span class="type">double</span>)*<span class="number">8</span>&lt;&lt;endl; <span class="comment">//96bits</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="内置类型的机器实现">内置类型的机器实现</h2><p>字节(Byte)是可寻址的最小内存块，1 byte = 8 bit(比特)</p><p>字(Word)是存储的基本单元，1 Word = 4字节或8字节</p><p>内存中每个字节与⼀个数字（被称为地址address）关联，我们能够使用某个地址来表示从这个地址开始的大小不同的比特串，如地址为736424的那个字或者地址736424的那个字节。但是必须知道存储在某地址的数据类型，才能赋予内存该地址明确含义，类型决定数据所占比特数，以及如何解释这些比特的内容。</p><h2 id="带符号型和无符号型">带符号型和无符号型</h2><p>其它整型</p><ul><li><p>除去布尔型和扩展字符型外，其它整型可划分为带符号的和无符号的</p></li><li><p>int, short, long, long long 带符号</p></li><li><p>类型名前添加<code>unsigned</code>得到无符号类型</p></li><li><p>如<code>unsigned long</code></p></li><li><p>unsigned int可简写为 unsigned)</p></li></ul><p>字符型</p><ul><li><p>分三种 char, signed char, unsigned char</p></li><li><p>char 表现为带符号还是无符号的，由编译器决定</p></li></ul><h3 id="如何选择类型">如何选择类型</h3><ol type="1"><li>数值不可能是负数时，比如年龄，长度等等，选用<code>无符号类型</code>；</li><li>整数计算式使用<code>int</code>类型，一般<code>long</code>的大小和<code>int</code>一样，而<code>short</code>显得太小。如果处理较大的整数，应该选择<code>long long</code>；</li><li>算数表达式中不要使用<code>bool</code>或<code>char</code>，符号容易出问题；</li><li>浮点数据运算使用<code>double</code>；</li></ol><h2 id="类型转换">类型转换</h2><p>类型所能表示值的范围决定转换过程：</p><ul><li>非布尔型赋给布尔型，初始值为0则结果为false， 否则为true。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">if</span> (i) &#123;</span><br><span class="line">i = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;i = &quot;</span> &lt;&lt; i &lt;&lt; endl;  <span class="comment">// i=0</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>布尔型赋给非布尔型，初始值为false结果为0，初始值为true结果为1。</li><li>浮点数赋给整型，近似处理，保留小数点前的部分。</li><li>整型赋给浮点型，小数部分记0，若整型超过浮点型容量则精度可能有损失。</li><li>超出范围值赋给无符号数，结果是初始值对无符号类型表示的最大值取模余数。</li><li>超出范围值赋给有符号数，结果未定义。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//test01.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">if</span> (i) &#123;</span><br><span class="line">i = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;i = &quot;</span> &lt;&lt; i &lt;&lt; endl;  <span class="comment">// i=0</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//test02.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">unsigned</span> u = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> i = <span class="number">-42</span>;</span><br><span class="line">std::cout &lt;&lt; i + i &lt;&lt; std::endl; <span class="comment">//-84</span></span><br><span class="line">std::cout &lt;&lt; u + i &lt;&lt; std::endl; <span class="comment">//4294967264</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//test03.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">10</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">std::cout &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; <span class="comment">//正常输出</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//test04.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">unsigned</span> u = <span class="number">10</span>; u &gt;= <span class="number">0</span>; --u) &#123;   <span class="comment">//无符号数不会小于0</span></span><br><span class="line">std::cout &lt;&lt; u &lt;&lt; std::endl;    <span class="comment">//死循环，ctrl+c退出</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//test05.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">unsigned</span> u = <span class="number">10</span>, u2 = <span class="number">42</span>;</span><br><span class="line">std::cout &lt;&lt; u2 - u &lt;&lt; std::endl;  <span class="comment">//32</span></span><br><span class="line">std::cout &lt;&lt; u - u2 &lt;&lt; std::endl;  <span class="comment">//4294967264</span></span><br><span class="line"><span class="type">int</span> i = <span class="number">10</span>, i2 = <span class="number">42</span>;</span><br><span class="line">std::cout &lt;&lt; i2 - i &lt;&lt; std::endl;  <span class="comment">//32</span></span><br><span class="line">std::cout &lt;&lt; i - i2 &lt;&lt; std::endl;  <span class="comment">//-32</span></span><br><span class="line">std::cout &lt;&lt; i - u &lt;&lt; std::endl;  <span class="comment">//0</span></span><br><span class="line">std::cout &lt;&lt; u - i &lt;&lt; std::endl; <span class="comment">//0</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="字面值常量literal-constants">字面值常量(Literal Constants)</h1><ol type="1"><li><strong>整型字面值常量:</strong></li></ol><ul><li>十进制 ：42</li><li>八进制: 052 (以0开头)</li><li>十六进制: 0x2A 或 0X2A (以 0x 或 0X 开头)</li><li>二进制: <code>0b101010</code> 或 <code>0B101010</code>（以 0b 或 0B开头）</li></ul><p>错误示范:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> month = <span class="number">9</span>, day = <span class="number">7</span>;</span><br><span class="line"><span class="type">int</span> month1 = <span class="number">09</span>, day1 = <span class="number">07</span>; <span class="comment">//以0开头会当成8进制赋值</span></span><br><span class="line">    <span class="comment">// [Error] invalid digit &quot;9&quot; in octal constant</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2" type="1"><li><strong>浮点型字面值常量</strong>:</li></ol><ul><li>十进制：<code>3.14</code> 或 <code>2.0</code></li><li>科学计数法：<code>3.0e8</code>（表示 3.0 乘以 10 的 8 次方）</li></ul><ol start="3" type="1"><li><strong>字符型字面值常量</strong>:</li></ol><ul><li>字符：<code>'A'</code> 或 <code>'x'</code></li><li>转义字符：<code>'\n'</code>（表示换行符）或<code>'\\'</code>（表示反斜杠）</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">转义序列:</span><br><span class="line">换行&#x27;\n&#x27;   横向制表符&#x27;\t&#x27;   响铃&#x27;\a&#x27;</span><br><span class="line">纵向制表符&#x27;\v&#x27;  退格符&#x27;\b&#x27;  双引号&#x27;\&quot;&#x27;</span><br><span class="line">反斜线&#x27;\\&#x27;  问号&#x27;\?&#x27;  单引号&#x27;\&#x27;&#x27;   回车&#x27;\r&#x27; </span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">泛化转义序列:&#x27;\x&#x27;跟1个多个16进制数，或&#x27;\&#x27;后跟1、2、3个8进制数</span><br><span class="line">&#x27;\7&#x27;响铃 &#x27;\12&#x27;换⾏ &#x27;\40&#x27;空格</span><br><span class="line">&#x27;\0&#x27;空字符 &#x27;\115&#x27;字符M &#x27;\x4d&#x27;字符M</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//test05.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;  <span class="comment">//换行</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;\tHi!\n&quot;</span>;  <span class="comment">//制表符,Hi!,换行</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;\v\?\abc\b\n&quot;</span>;  <span class="comment">//纵向制表符,?,响铃,bc,退格,换行</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Hi \x4dO\115!\n&quot;</span>;  <span class="comment">//Hi MOM!,换行</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&#x27;\115&#x27;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;  <span class="comment">//M,换行</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4" type="1"><li><strong>字符串字面值常量</strong>：字符串字面值常量表示一串字符，使用双引号括起来。例如：</li></ol><ul><li>字符串：<code>"Hello, World!"</code></li></ul><blockquote><p>字符串实际类型是字符数组，结尾添加'\0'字符字符串型实际上是常量字符构成的数组，结尾处以'\0'结束，所以字符串类型实际 上长度比内容多1。</p></blockquote><ol start="5" type="1"><li><p><strong>布尔字面值常量</strong>：布尔字面值常量表示真或假，可以是<code>true</code> 或 <code>false</code>。</p></li><li><p><strong>指针字面值:</strong> nullptr</p></li><li><p><strong>指定字面值类型:</strong></p></li></ol><p>字符和字符串字面值:</p><table><thead><tr class="header"><th style="text-align: center;">前缀</th><th style="text-align: center;">含义</th><th style="text-align: center;">类型</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">u</td><td style="text-align: center;">Unicode16字符</td><td style="text-align: center;">char16_t</td></tr><tr class="even"><td style="text-align: center;">U</td><td style="text-align: center;">Unicode32字符</td><td style="text-align: center;">char32_t</td></tr><tr class="odd"><td style="text-align: center;">L</td><td style="text-align: center;">宽字符</td><td style="text-align: center;">wchar_t</td></tr><tr class="even"><td style="text-align: center;">u8</td><td style="text-align: center;">UTF-8(字符串字⾯常量)</td><td style="text-align: center;">char</td></tr></tbody></table><p>整型字面值:</p><table><thead><tr class="header"><th style="text-align: center;">后缀</th><th style="text-align: center;">最小匹配类型</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">u or U</td><td style="text-align: center;">unsigned</td></tr><tr class="even"><td style="text-align: center;">l or L</td><td style="text-align: center;">long</td></tr><tr class="odd"><td style="text-align: center;">ll or LL</td><td style="text-align: center;">long long</td></tr></tbody></table><p>浮点型字面值:</p><table><thead><tr class="header"><th style="text-align: center;">后缀</th><th style="text-align: center;">类型</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">f or F</td><td style="text-align: center;">float</td></tr><tr class="even"><td style="text-align: center;">l or L</td><td style="text-align: center;">long double</td></tr></tbody></table><h1 id="变量">变量</h1><blockquote><p>变量提供⼀个具名的、可供程序操作的存储空间。C++中变量和对象⼀般可以互换使用</p></blockquote><h2 id="define">define</h2><ul><li><p>定义形式：类型说明符（type specifier） +⼀个或多个变量名组成的列表;</p></li><li><p>初始化（initialize）：对象在创建时获得了⼀个特定的值。</p></li><li><ul><li>初始化不是赋值 ，初始化 = 创建变量 + 赋予初始值 ，赋值 =擦除对象的当前值 + 用新值代替</li></ul></li><li><p>列表初始化：使用花括号{}</p></li><li><p>若列表初始化且初始值存在丢失信息的风险，则编译器将报错。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int a&#123;3.14&#125;;</span><br><span class="line"></span><br><span class="line">// error: narrowing conversion from ‘double’ to ‘int’ </span><br></pre></td></tr></table></figure></li><li><p>默认初始化：定义时没有指定初始值会被默认初始化；</p></li><li><p>在函数体内部的内置类型变量将不会被初始化。</p></li><li><p>类的对象如果没有显⽰初始化，其值由类定义。</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">std::string global_str;  <span class="comment">//定义全局变量global_str,初值为空字符串</span></span><br><span class="line"><span class="type">int</span> global_int;  <span class="comment">//定义全局变量global_int,初值为0</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> local_int; <span class="comment">//局部变量未初始化，初值未定义</span></span><br><span class="line">std::string local_str; </span><br><span class="line">    <span class="comment">//local_str 是 string类的对象，它的值由类确定，为空字符串。</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>建议初始化每⼀个内置类型变量！</strong></p><h2 id="变量声明与定义的联系">变量声明与定义的联系</h2><p>把程序拆分成多个逻辑部分来编写，C++支持<strong>分离式编译机制</strong>，程序分割为若干文件，每个文件可被独立编译，为了支持分离式编译，C++将声明和定义区分开。</p><p>声明使得名字为程序所知，定义负责创建与名字关联的实体。</p><p>声明规定了变量类型和名字。定义申请存储空间，也可能为变量赋初值。想声明⼀个变量而非定义它，在变量名前加关键字<code>extern</code>,不要显示初始化变量。</p><p>变量只能被定义⼀次，但是可以多次声明,定义只出现在⼀个文件中，其他文件使用该变量时需要对其声明。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> i;  <span class="comment">//声明i而非定义 </span></span><br><span class="line"><span class="type">int</span> j;  <span class="comment">//声明并定义j </span></span><br><span class="line"><span class="comment">// 包含了显示初始化的声明，就变成了定义：</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">double</span> pi = <span class="number">3.14</span>;  <span class="comment">//定义</span></span><br><span class="line"><span class="comment">// 函数体内部，试图初始化⼀个extern关键字标记的变量，将引发错误。</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> ix = <span class="number">1024</span>; <span class="comment">//定义</span></span><br><span class="line"><span class="type">int</span> iy;  <span class="comment">//定义</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> iz;  <span class="comment">//声明</span></span><br></pre></td></tr></table></figure><h2 id="变量标识符与命名规范">变量标识符与命名规范</h2><p>标识符:</p><ol type="1"><li>由字母、数字、下划线组成，必须以字母或下划线开头。</li></ol><ul><li><p>长度没有限制。</p></li><li><p>大小写写敏感。</p></li></ul><ol start="2" type="1"><li><p>保留名字不能用做标识符。</p></li><li><p>用户自定义标识符</p></li></ol><ul><li>不能连续出现两个下划线</li><li>不能以下划线紧跟大写字母开头</li><li>定义在函数体外的标识符不能以下划线开头</li><li>使用小驼峰命名法</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//c++关键字</span></span><br><span class="line"><span class="keyword">alignas</span>  <span class="keyword">continue</span>  <span class="keyword">friend</span>  <span class="keyword">register</span>  <span class="literal">true</span></span><br><span class="line"><span class="keyword">alignof</span>  <span class="keyword">decltype</span>  <span class="keyword">goto</span>  <span class="keyword">reinterpret_cast</span>  <span class="keyword">try</span></span><br><span class="line"><span class="keyword">asm</span>  <span class="keyword">default</span>  <span class="keyword">if</span>  <span class="keyword">return</span>  <span class="keyword">typedef</span></span><br><span class="line"><span class="keyword">auto</span>  <span class="keyword">delete</span>  <span class="keyword">inline</span>  <span class="type">short</span>  <span class="keyword">typeid</span></span><br><span class="line"><span class="type">bool</span>  <span class="keyword">do</span>  <span class="type">int</span>  <span class="type">signed</span>  <span class="keyword">typename</span></span><br><span class="line"><span class="keyword">break</span>  <span class="type">double</span>  <span class="type">long</span>  <span class="keyword">sizeof</span>  <span class="keyword">union</span></span><br><span class="line"><span class="keyword">case</span>  <span class="keyword">dynamic_cast</span>  <span class="keyword">mutable</span>  <span class="type">static</span>  <span class="type">unsigned</span></span><br><span class="line"><span class="keyword">catch</span>  <span class="keyword">else</span>  <span class="keyword">namespace</span>  <span class="keyword">static_assert</span>  <span class="keyword">using</span></span><br><span class="line"><span class="type">char</span>  <span class="keyword">enum</span>  <span class="keyword">new</span>  <span class="keyword">static_cast</span>  <span class="keyword">virtual</span></span><br><span class="line"><span class="type">char16_t</span> <span class="keyword">explicit</span>  <span class="keyword">noexcept</span>  <span class="keyword">struct</span>  <span class="type">void</span></span><br><span class="line"><span class="type">char16_t</span> <span class="keyword">export</span>  <span class="literal">nullptr</span>  <span class="keyword">switch</span>  <span class="keyword">volatile</span></span><br><span class="line"><span class="keyword">class</span>  <span class="keyword">extern</span>  <span class="keyword">operator</span>  <span class="keyword">template</span>  <span class="type">wchar_t</span></span><br><span class="line"><span class="type">const</span>  <span class="literal">false</span>  <span class="keyword">private</span>  <span class="keyword">this</span>  <span class="keyword">while</span></span><br><span class="line"><span class="keyword">constexpr</span>  <span class="type">float</span>  <span class="keyword">protected</span>  <span class="keyword">thread_local</span></span><br><span class="line"><span class="keyword">const_cast</span>  <span class="keyword">for</span>  <span class="keyword">public</span>  <span class="keyword">throw</span></span><br><span class="line"><span class="comment">//c++操作符替代名</span></span><br><span class="line"><span class="keyword">and</span>  <span class="keyword">bitand</span>  <span class="keyword">compl</span>  <span class="keyword">not_eq</span>  <span class="keyword">or_eq</span>  <span class="keyword">xor_eq</span></span><br><span class="line"><span class="keyword">and_eq</span>  <span class="keyword">bitor</span>  <span class="keyword">not</span>  <span class="keyword">or</span>  <span class="keyword">xor</span></span><br></pre></td></tr></table></figure><p>命名规范:</p><ol type="1"><li>体现实际含义</li><li>变量名和函数名使用小驼峰命名法，如<code>myVariable</code></li><li>自定义类名大写字母开头，如<code>Sales_item</code></li><li>若标识符有多个单词组成，单词之间要有明显区分，如<code>student_loan</code>,<code>studentLoan</code>,不要用<code>studentloan</code></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="type">double</span> = <span class="number">3.14</span>;  <span class="comment">//error</span></span><br><span class="line"><span class="type">int</span> _;</span><br><span class="line"><span class="type">int</span> <span class="keyword">catch</span><span class="number">-22</span>;  <span class="comment">//error</span></span><br><span class="line"><span class="type">int</span> <span class="number">1</span>_or_2 = <span class="number">1</span>;  <span class="comment">//error</span></span><br><span class="line"><span class="type">double</span> Double = <span class="number">3.14</span>;</span><br></pre></td></tr></table></figure><p>名字的作用域（namescope），以{}分隔</p><ul><li>全局作用域</li><li>块作用域</li></ul><p>第⼀次使用变量时再定义它， 更容易找到，赋予比较合理的初始值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//scope.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">// Program for illustration purposes only: It is bad style for a function</span></span><br><span class="line"><span class="comment">// to use a global variable and also define a local variable with the same</span></span><br><span class="line"><span class="type">int</span> reused = <span class="number">42</span>; <span class="comment">// reused has global scope</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> unique = <span class="number">0</span>; <span class="comment">// unique has block scope</span></span><br><span class="line"><span class="comment">// output #1: uses global reused; prints 42 0</span></span><br><span class="line">std::cout &lt;&lt; reused &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; unique &lt;&lt; std::endl;</span><br><span class="line"><span class="type">int</span> reused = <span class="number">0</span>; <span class="comment">// new, local object named reused hides global reused</span></span><br><span class="line"><span class="comment">// output #2: uses local reused; prints 0 0</span></span><br><span class="line">std::cout &lt;&lt; reused &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; unique &lt;&lt; std::endl; </span><br><span class="line">    <span class="comment">//此时全局变量被同名的局部变量覆盖</span></span><br><span class="line"><span class="comment">// output #3: explicitly requests the global reused; prints 42 0</span></span><br><span class="line">std::cout &lt;&lt; ::reused &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; unique &lt;&lt; std::endl;  </span><br><span class="line">    <span class="comment">//使用全局变量</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>嵌套的作用域:</p><p>同时存在全局和局部变量时,已定义局部变量的作用域中可用<code>::</code>显式访问全局变量。用到全局变量时，尽量不使用重名的局部变量。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="type">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> i = <span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> j = i;</span><br><span class="line"><span class="comment">//j的值是100，局部变量i覆盖了全局变量i</span></span><br><span class="line">std::cout &lt;&lt; j &lt;&lt; std::endl; <span class="comment">//100</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//下面的程序合法吗？如果合法，它将输出什么？</span></span><br><span class="line"><span class="type">int</span> i = <span class="number">100</span>, sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i != <span class="number">10</span>; ++i)</span><br><span class="line">sum += i;  <span class="comment">//此时的变量i仅在for循环内生效</span></span><br><span class="line">std::cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; sum &lt;&lt; std::endl;</span><br><span class="line"><span class="comment">//合法输出:100 45 </span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="左值和右值">左值和右值</h3><ul><li><p>左值（l-value）可以出现在赋值语句的左边或者右边，比如变量；</p></li><li><p>右值（r-value）只能出现在赋值语句的右边，比如常量。</p></li></ul><h2 id="引用">引用</h2><blockquote><p>⼀般说的引用是指的左值引用</p></blockquote><p>引用：引用是为对象起了另外⼀个名字，引用类型:引用（referto）另外⼀种类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> &amp;refVal = val; </span><br></pre></td></tr></table></figure><ol type="1"><li>引用必须初始化:</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> &amp;refVal2;  <span class="comment">//报错，引用必须被初始化 </span></span><br></pre></td></tr></table></figure><ol start="2" type="1"><li>引用和它的初始值是<strong>绑定bind</strong>在⼀起的，而不是拷贝。⼀旦定义就不能更改绑定为其他的对象</li><li>引用类型要与绑定对象匹配</li><li>引用只能绑定在对象上，不能与字面值或表达式计算结果绑定</li></ol><p>更详细的解释可参考：<a href="https://lgq007.github.io/2023/07/15/C++%E4%B8%AD%E7%9A%84%E5%BC%95%E7%94%A8/">C++中的引用</a></p><h2 id="指针">指针</h2><blockquote><p>是⼀种 "指向（point to）"另外⼀种类型的复合类型。本身就是⼀个对象，无需定义时赋值</p></blockquote><h3 id="定义指针类型">定义指针类型</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *ip1,*ip2;</span><br><span class="line"><span class="comment">//ip1和ip2都是int型对象指针</span></span><br><span class="line"><span class="type">double</span> dp,*dp2</span><br><span class="line"><span class="comment">//dp2 是指向double型对象的指针，dp是double类型</span></span><br></pre></td></tr></table></figure><h3 id="获取对象的地址">获取对象的地址</h3><p>指针存放某个对象的地址。 获取对象的地址：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i=<span class="number">42</span>;</span><br><span class="line"><span class="type">int</span> *p = &amp;i; </span><br></pre></td></tr></table></figure><p><code>&amp;</code>是取地址符。<strong>指针的类型与所指向的对象类型必须⼀致</strong>（均为同一类型int、double等）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ival = <span class="number">42</span>;</span><br><span class="line"><span class="type">int</span> *p = &amp;ival; <span class="comment">//p存放ival的地址，p是指向val的指针</span></span><br><span class="line"></span><br><span class="line"><span class="type">double</span> dval;</span><br><span class="line"><span class="type">double</span> *pd = &amp;dval;<span class="comment">//正确</span></span><br><span class="line"><span class="type">double</span> *pd2 = pd;<span class="comment">//正确</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> *pi = pd;<span class="comment">//错误，类型不匹配</span></span><br><span class="line">pi = &amp;dval;<span class="comment">//错误，试图把double对象的地址赋给int指针</span></span><br></pre></td></tr></table></figure><p>指针的值(即地址)的四种状态：</p><ol type="1"><li>指向⼀个对象；</li><li>指向紧邻对象的下⼀个位置；</li><li>空指针；</li><li>无效指针。</li></ol><p>对无效指针的操作均会引发错误;</p><p>第二种和第三种虽为有效的，访问指针对象的行为后果无法预计。</p><h3 id="指针访问对象">指针访问对象</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//如果指针指向一个对象，使用解引用符（操作符&#x27;*&#x27;）来访问对象</span></span><br><span class="line"><span class="type">int</span> ival = <span class="number">42</span>;</span><br><span class="line"><span class="type">int</span> *p = &amp;ival;</span><br><span class="line">std::cout &lt;&lt; *p;<span class="comment">// 输出p指针所指对象的数据，</span></span><br><span class="line">*p = <span class="number">0</span>;</span><br><span class="line">std::cout &lt;&lt; ival; <span class="comment">// 0</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解引用操作仅适用于确实指向某个对象的有效指针。</p><h3 id="空指针">空指针</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p1=<span class="literal">nullptr</span>; <span class="comment">//使用空指针。</span></span><br><span class="line"><span class="type">int</span> *p2 = <span class="number">0</span>;<span class="comment">//p2 初始化为字面常量0</span></span><br><span class="line"><span class="comment">// include&lt;cstdlib&gt;</span></span><br><span class="line"><span class="type">int</span> *p3 = <span class="literal">NULL</span>;<span class="comment">//int *p3=0 NULL预处理变量</span></span><br><span class="line"><span class="type">int</span> zero = <span class="number">0</span>;</span><br><span class="line">p1 = zero; <span class="comment">//错误，不能把int变量直接赋给指针</span></span><br></pre></td></tr></table></figure><p><strong>建议初始化所有指针！</strong></p><h3 id="指针与引用的区别">指针与引用的区别</h3><ul><li>引用本身并非⼀个对象，引用定义后就不能绑定到其他的对象上了；</li><li>指针并没有此限制</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//说明指针和引用的主要区别</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//引用是另⼀个对象的别名，而指针本身就是⼀个对象。</span></span><br><span class="line"><span class="comment">//引用必须初始化，并且⼀旦定义了引用就无法再绑定到其他对象。</span></span><br><span class="line"><span class="comment">//而指针无须在定义时赋初值，也可以重新赋值让其指向其他对象。</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="type">int</span> *pi = <span class="number">0</span>;<span class="comment">//pi 初始化，没有指向任何对象</span></span><br><span class="line"><span class="type">int</span> *pi2 = &amp;i;<span class="comment">//pi2指向i</span></span><br><span class="line"><span class="type">int</span> *pi3;<span class="comment">//如果pi3定于于块内，pi3值无法确定</span></span><br><span class="line"></span><br><span class="line">pi3 = pi2;<span class="comment">//pi3与pi2指向同⼀对象i</span></span><br><span class="line">pi2 = <span class="number">0</span>;<span class="comment">//pi2 不指向任何对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//赋值语句永远改变的是左侧的对象。</span></span><br><span class="line">pi = &amp;ival;<span class="comment">//pi指向了ival</span></span><br><span class="line">*pi = <span class="number">0</span>;<span class="comment">//ival值改变，pi没改变</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//请解释下述定义。在这些定义中有非法的吗？如果有，为什么？</span></span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">(a) <span class="type">double</span>* dp = &amp;i;</span><br><span class="line">(b) <span class="type">int</span> *ip = i;</span><br><span class="line">(c) <span class="type">int</span> *p = &amp;i;</span><br><span class="line">(a): ⾮法。不能将⼀个指向 <span class="type">double</span> 的指针指向 <span class="type">int</span> 。</span><br><span class="line">(b): ⾮法。不能将 <span class="type">int</span> 变量赋给指针。</span><br><span class="line">(c): 合法。</span><br></pre></td></tr></table></figure><h3 id="其他指针操作">其他指针操作</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ival = <span class="number">1024</span>;</span><br><span class="line"><span class="type">int</span> *p1=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> *p2=&amp;ival;</span><br><span class="line"><span class="comment">//指针值0，条件取false</span></span><br><span class="line"><span class="keyword">if</span>(p1)</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="comment">//p2指针⾮0，条件值是true</span></span><br><span class="line"><span class="keyword">if</span>(p2)</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="comment">//指针⽐较</span></span><br><span class="line"><span class="keyword">if</span>(p1==p2)</span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure><p><strong>非法指针会引发不可预计的后果!</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//⼀条语句定义不同类型变量</span></span><br><span class="line"><span class="type">int</span> i=<span class="number">1024</span>,</span><br><span class="line">*p=&amp;i,&amp;r=i;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>* p;<span class="comment">//合法但容易产⽣误导</span></span><br><span class="line"><span class="type">int</span>* p1,p2;<span class="comment">//p1是指针,p2是int</span></span><br><span class="line"><span class="type">int</span> *p1,*p2;<span class="comment">//p1,p2都是指针</span></span><br><span class="line">或</span><br><span class="line"><span class="type">int</span> *p1;</span><br><span class="line"><span class="type">int</span> *p2;</span><br></pre></td></tr></table></figure><h4 id="指向指针的指针">指向指针的指针</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> ival = <span class="number">1024</span>;</span><br><span class="line"><span class="type">int</span> *pi = &amp;ival;  <span class="comment">//pi指向int型</span></span><br><span class="line"><span class="type">int</span> **ppi = &amp;pi; <span class="comment">//ppi指向int型指针</span></span><br><span class="line"><span class="comment">// 解引用</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;The value of ival\n&quot;</span>  </span><br><span class="line">     &lt;&lt; <span class="string">&quot;direct value: &quot;</span> &lt;&lt; ival &lt;&lt; <span class="string">&quot;\n&quot;</span></span><br><span class="line">     &lt;&lt; <span class="string">&quot;indirect value: &quot;</span> &lt;&lt; *pi &lt;&lt; <span class="string">&quot;\n&quot;</span></span><br><span class="line">     &lt;&lt; <span class="string">&quot;doubly indirect value: &quot;</span> &lt;&lt; **ppi</span><br><span class="line">     &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">//The value of ival</span></span><br><span class="line"><span class="comment">//direct value: 1024</span></span><br><span class="line"><span class="comment">//indirect value: 1024</span></span><br><span class="line"><span class="comment">//doubly indirect value: 1024</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="指向指针的引用">指向指针的引用</h4><p>从右向左阅读r的定义</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i=<span class="number">42</span>;</span><br><span class="line"><span class="type">int</span> *p;</span><br><span class="line"><span class="type">int</span> *&amp;r = p;  <span class="comment">//r是对指针p的引用</span></span><br><span class="line">r = &amp;i;  <span class="comment">//p指向i</span></span><br><span class="line">*r=<span class="number">0</span>;  <span class="comment">//i=0</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">说明下列变量的类型和值。</span><br><span class="line">(a) <span class="type">int</span>* ip, i, &amp;r = i;</span><br><span class="line">(b) <span class="type">int</span> i,*ip = <span class="number">0</span>;</span><br><span class="line">(c) <span class="type">int</span>* ip, ip2;</span><br><span class="line"></span><br><span class="line">(a): ip 是⼀个指向 <span class="type">int</span> 的指针, i 是⼀个 <span class="type">int</span>, r 是 i 的引⽤。</span><br><span class="line">(b): i 是 <span class="type">int</span> , ip 是⼀个空指针。</span><br><span class="line">(c): ip 是⼀个指向 <span class="type">int</span> 的指针, ip2 是⼀个 <span class="type">int</span>。</span><br></pre></td></tr></table></figure><h3 id="void指针">void指针</h3><p><code>void</code>指针可以存放任意对象的地址。因无类型，仅操作内存空间，不能直接操作<code>void *</code>指针所指的对象。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> obj = <span class="number">3.14</span>,</span><br><span class="line">*pd = &amp;obj;</span><br><span class="line"><span class="type">void</span> *pv = &amp;obj; <span class="comment">//obj 可以是任意类型的对象</span></span><br><span class="line">pv = pd;<span class="comment">//void* 可存任何类型,使用时再进行强制类型转换即可</span></span><br></pre></td></tr></table></figure><h1 id="const限定符">CONST限定符</h1><blockquote><p>const：定义⼀些不能被改变值的变量，const对象⼀旦创建值不再改变，所以必须初始化，且不能被改变。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> bufSize = <span class="number">512</span>;</span><br><span class="line">bufSize = <span class="number">512</span>;<span class="comment">//error，试图写值到const对象</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> i= <span class="built_in">getSize</span>();</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> j=<span class="number">42</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> k;<span class="comment">//error,k未初始化常量</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i=<span class="number">42</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> ci=i;</span><br><span class="line"><span class="type">int</span> j=ci;</span><br></pre></td></tr></table></figure><p>CONST对象仅在文件内有效：</p><ul><li><p>当多个文件出现同名的const变量，等同于在不同文件分别定义独立变量。</p></li><li><p>要想在多个文件中使用const变量共享，定义和声明都加extern关键字即可。</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file_1.cc定义初始化常量，能被其它文件访问</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="type">int</span> bufSize = <span class="built_in">fcn</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//file_1.h 头文件</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="type">int</span> bufSize ;<span class="comment">//与file_1.cc中定义的bufSize是同⼀个</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> buf;  <span class="comment">// 不合法, const 对象必须初始化</span></span><br><span class="line"><span class="type">int</span> cnt = <span class="number">0</span>;  <span class="comment">// 合法</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> sz = cnt;  <span class="comment">// 合法</span></span><br><span class="line">++cnt; ++sz;  <span class="comment">// 不合法, const 对象不能被改变</span></span><br></pre></td></tr></table></figure><h2 id="const的引用">const的引用</h2><ul><li>把引用绑定到const对象上，称之为对常量的引用。</li><li>与普通引用不同，对常量的引用不能被用作修改它所绑定的对象</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> ci=<span class="number">1024</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;r1=ci;</span><br><span class="line">r1=<span class="number">42</span>;  <span class="comment">//error r1是对常量的引用</span></span><br><span class="line"><span class="type">int</span> &amp;r2 = ci;  <span class="comment">//error,试图让非常量引用指向⼀个常量对象</span></span><br></pre></td></tr></table></figure><h3 id="初始化和对const的引用">初始化和对const的引用</h3><p>引用类型必须与其所用对象类型一致</p><ul><li>例外：初始化常量引用时，允许用任意表达式做初始值，只要表达式的结果能转换成引用的类型。</li><li>允许为一个常量引用绑定非常量的对象，字面值，一个一般表达式</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i=<span class="number">42</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;r1=i;  <span class="comment">//允许将const int&amp;绑定到int对象</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;r2=<span class="number">42</span>;<span class="comment">//r2 是个常量引用</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;r3=r1*<span class="number">2</span>;<span class="comment">//r3是个常量引用</span></span><br><span class="line"><span class="type">int</span> &amp;r4=r1*<span class="number">2</span>;<span class="comment">//error，r4是⼀个普通的非常量引用。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//当⼀个常量引用被绑定到另外⼀种类型发生了什么？</span></span><br><span class="line"><span class="type">double</span> dval = <span class="number">3.14</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;ri=dval;</span><br><span class="line"><span class="comment">//编译器将上述代码改为如下形式</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> temp=dval;<span class="comment">//生成临时整型变量</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;ri=temp;<span class="comment">//让ri绑定这个临时变量</span></span><br></pre></td></tr></table></figure><ul><li>临时量(temporary)对象：当编译器需要一个空间来暂存表达式结果的值时，临时创建的一个未命名的变量</li><li>对临时量的引用是错误行为:</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> dval = <span class="number">3.14</span>;</span><br><span class="line"><span class="type">int</span> &amp;ri = dval; <span class="comment">//error</span></span><br></pre></td></tr></table></figure><p><strong>对const的引用很可能引用一个非const对象</strong></p><ul><li>常量引用仅对引用可参与的操作做出限定，对引用的对象本身是不是常量未做限定</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="type">int</span> &amp;r1 = i; <span class="comment">//r1绑定i</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;r2 = i;  <span class="comment">//r2绑定i，不允许通过r2修改i</span></span><br><span class="line">r1 = <span class="number">0</span>;  <span class="comment">//ok，r1非常量</span></span><br><span class="line">r2 = <span class="number">0</span>;  <span class="comment">//error，r2是一个常量引用</span></span><br></pre></td></tr></table></figure><p>和常量引用⼀样，指向常量的指针同理也没有规定所指对象必须是常量。仅要求不能通过指针改变对象值。</p><h2 id="const指针">const指针</h2><p>常量指针必须初始化，允许把指针定义成常量：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> errNumb=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> *<span class="type">const</span> curErr=&amp;errNumb;<span class="comment">// curErr是常量，⼀直指向errNumb(地址不能变)</span></span><br><span class="line"><span class="type">const</span> <span class="type">double</span> pi=<span class="number">3.1415</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> *<span class="type">const</span> pip= &amp;pi;<span class="comment">//pip是常量，*pip也是常量,</span></span><br><span class="line"><span class="comment">//pip 是指向常量对象的常量指针 (值与地址均不能更改)</span></span><br><span class="line">*pip = <span class="number">2.72</span>;<span class="comment">//error *pip 是常量</span></span><br><span class="line"><span class="keyword">if</span>(*curErr)&#123;</span><br><span class="line"><span class="built_in">errorHandler</span>();</span><br><span class="line">*curErr=<span class="number">0</span>;<span class="comment">//ok *curErr不是常量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//下面的哪些初始化是合法的？请说明原因。</span></span><br><span class="line"><span class="type">int</span> i = <span class="number">-1</span>, &amp;r = <span class="number">0</span>; <span class="comment">// 不合法, r 必须引用⼀个对象</span></span><br><span class="line"><span class="type">int</span> *<span class="type">const</span> p2 = &amp;i2; <span class="comment">// 合法，常量指针</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> i = <span class="number">-1</span>, &amp;r = <span class="number">0</span>(常量引用); <span class="comment">// 合法</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *<span class="type">const</span> p3 = &amp;i2; <span class="comment">// 合法</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *p1 = &amp;i2; <span class="comment">// 合法</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;<span class="type">const</span> r2; <span class="comment">// 不合法, r2 是引用，没有顶层const</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> i2 = i, &amp;r = i; <span class="comment">// 合法</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//说明下面的这些定义是什么意思，挑出其中不合法的。</span></span><br><span class="line"><span class="type">int</span> i,*<span class="type">const</span> cp; <span class="comment">// 不合法, const 指针必须初始化</span></span><br><span class="line"><span class="type">int</span> *p1,*<span class="type">const</span> p2; <span class="comment">// 不合法, const 指针必须初始化</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> ic, &amp;r = ic; <span class="comment">// 不合法, const int 必须初始化</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *<span class="type">const</span> p3; <span class="comment">// 不合法, const 指针必须初始化</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *p; <span class="comment">// 合法. ⼀个指针，指向 const int</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//假设已有上⼀个练习中定义的那些变量，则下⾯的哪些语句是合法的？请说明原因。</span></span><br><span class="line">i = ic; <span class="comment">// 合法, 常量赋值给普通变量</span></span><br><span class="line">p1 = p3; <span class="comment">// 不合法, p3 是const指针,不能赋值给普通指针</span></span><br><span class="line">p1 = &amp;ic; <span class="comment">// 不合法, 普通指针不能指向常量</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> * <span class="type">const</span> p3 = &amp;ic; <span class="comment">// 合法, p3 是常量指针且指向常量</span></span><br><span class="line">p3 = &amp;ic; <span class="comment">//此时不合法 p3 常量</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> * <span class="type">const</span> p2 = p1; <span class="comment">// 合法, 可以将普通指针赋值给常量指针</span></span><br><span class="line">p2 = p1;<span class="comment">//此时不合法 p2是常量</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> ic = *p3; <span class="comment">// 合法, 对 p3 取值后是⼀个 int 然后赋值给 ic</span></span><br><span class="line">ic = *p3;<span class="comment">//此时不合法，ic是常量</span></span><br></pre></td></tr></table></figure><h3 id="顶层const">顶层const</h3><ul><li>顶层const：指针本身是个常量。</li><li>底层const：指针指向的对象是个常量。拷贝时严格要求相同的底层const资格。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> *<span class="type">const</span> p1=&amp;i;<span class="comment">//p1常量，顶层const</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> ci=<span class="number">42</span>;<span class="comment">//ci常量，顶层const</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *p2=&amp;ci;<span class="comment">//*p2常量，底层const</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *<span class="type">const</span> p3=p2;<span class="comment">//靠右顶层，靠左底层const</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;r =ci;<span class="comment">//用于声明引用的const都是底层const</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//拷贝时，顶层const不受影响</span></span><br><span class="line">i=ci;<span class="comment">//拷贝ci的值，ci顶层const，⽆影响</span></span><br><span class="line">p2=p3;<span class="comment">//p2 p3所指对象类型相同 p3顶层const部分不影响</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//拷贝时严格要求相同的底层const资格,数据类型能够转换。</span></span><br><span class="line"><span class="type">int</span> *p =p3;<span class="comment">//error p3包含底层const定义，p没有</span></span><br><span class="line">p2=p3;<span class="comment">//ok p2 p3都是底层const</span></span><br><span class="line">p2=&amp;i; <span class="comment">//ok int* 转const int*</span></span><br><span class="line"><span class="type">int</span> &amp;r=ci;<span class="comment">//error 普通int&amp; 不能绑定到int 常量</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;r2=i;<span class="comment">//ok const int&amp; 可以绑定到int</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对于下面的这些语句，请说明对象被声明成了顶层const还是底层const？</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> v2 = <span class="number">0</span>; <span class="type">int</span> v1 = v2;</span><br><span class="line"><span class="type">int</span> *p1 = &amp;v1, &amp;r1 = v1;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *p2 = &amp;v2,</span><br><span class="line">*<span class="type">const</span> p3 = &amp;i, &amp;r2 = v2;</span><br><span class="line"><span class="comment">//v2 是顶层const，p2 是底层const，p3 既是顶层const⼜是底层const，r2 是底层const。</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//假设已有上⼀个练习中所做的那些声明，则下面的哪些语句是合法的？</span></span><br><span class="line"><span class="comment">//请说明顶层const和底层const在每个例子中有何体现。</span></span><br><span class="line">r1 = v2; <span class="comment">// 合法, 顶层const在拷贝时不受影响</span></span><br><span class="line">p1 = p2; <span class="comment">// 不合法, p2 是底层const，如果要拷贝必须要求 p1 也是底层const</span></span><br><span class="line">p2 = p1; <span class="comment">// 合法, int* 可以转换成const int*</span></span><br><span class="line">p1 = p3; <span class="comment">// 不合法, p3 是⼀个底层const，p1 不是</span></span><br><span class="line">p2 = p3; <span class="comment">// 合法, p2 和 p3 都是底层const，拷贝时忽略掉顶层const</span></span><br></pre></td></tr></table></figure><h2 id="constexpr和常量表达式">constexpr和常量表达式</h2><ul><li>常量表达式：指值不会改变，且在编译过程中就能得到计算结果的表达式。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//⼀个对象（表达式）是不是常量表达式由数据类型和初始值共同决定</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> max_file=<span class="number">30</span>;  <span class="comment">//max_file是常量表达式</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> limit = max_file+<span class="number">1</span>;  <span class="comment">//limit是常量表达式</span></span><br><span class="line"><span class="type">int</span> staff_size = <span class="number">7</span>;  <span class="comment">//staff_size不是常量表达式</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> sz = <span class="built_in">get_size</span>();  <span class="comment">//运⾏时获取，sz是常量表达式。</span></span><br></pre></td></tr></table></figure><ul><li>C++11新标准规定，允许将变量声明为<code>constexpr</code>类型以便由编译器来验证变量的值是否是⼀个常量的表达式。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> mf = <span class="number">20</span>;  <span class="comment">//20是常量表达式</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> limit = mf+<span class="number">1</span>;  <span class="comment">//mf+1是常量表达式</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> sz = <span class="built_in">get_size</span>(); <span class="comment">//取决于get_size()是否是constexpr函数</span></span><br></pre></td></tr></table></figure><h3 id="字面值类型">字面值类型</h3><p>常量表达式的值编译时就得到计算，类型简单，值容易得到，称为为“字面值类型”（literal type）</p><ul><li>算数类型</li><li>引用，指针，nullptr，0或固定位置</li></ul><h2 id="指针和constexpr">指针和constexpr</h2><ul><li>constexpr把所定义的对象置为顶层</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> *p=<span class="literal">nullptr</span>;<span class="comment">//p是⼀个指向常量的指针</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> *q=<span class="literal">nullptr</span>;<span class="comment">//q是常量指针</span></span><br><span class="line"><span class="comment">//constexpr把所定义的对象置为顶层</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> *nq=<span class="literal">nullptr</span>;<span class="comment">//nq是常量指针</span></span><br><span class="line"><span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> i=<span class="number">42</span>;<span class="comment">//i是常量</span></span><br><span class="line"><span class="comment">//i,j定义在函数外</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">const</span> <span class="type">int</span> *p=&amp;i;<span class="comment">//p是常量指针,指向整型常量i</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> *p1=&amp;j;<span class="comment">//p1是常量指针，指向整数j</span></span><br></pre></td></tr></table></figure><h1 id="处理类型">处理类型</h1><ul><li>程序越来越复杂，类型越来越复杂。类型难于拼写，明确目的含义，搞不清需要什么类型。</li></ul><h2 id="类型别名">类型别名</h2><ul><li><p>传统别名：使用<code>typedef</code>来定义类型的同义词。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> wages; </span><br><span class="line">wages hour,weekly;  <span class="comment">//double hour,weekly;</span></span><br></pre></td></tr></table></figure></li><li><p>新标准别名：别名声明（alias declaration）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> SI = Sales_item;  <span class="comment">//（C++11）</span></span><br><span class="line">SI items;<span class="comment">//Sales_item items;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="指针常量和类型别名">指针，常量和类型别名</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对于复合类型（指针等）不能代回原式来进行理解</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> *pstring;  <span class="comment">// pstring是char*的别名</span></span><br><span class="line"><span class="type">const</span> pstring cstr = <span class="number">0</span>; <span class="comment">// cstr是指向char的常量指针</span></span><br><span class="line"><span class="type">const</span> pstring *ps;<span class="comment">//ps是⼀个指针，对象是指向char的常量指针</span></span><br><span class="line"><span class="comment">//基本数据类型是指针而不是const char。</span></span><br></pre></td></tr></table></figure><h2 id="auto类型说明符-c-11">AUTO类型说明符 (C++ 11)</h2><p>清楚的知道表达式类型并不容易，因此引入<code>auto</code>。</p><ul><li>auto类型说明符：让编译器自行推断类型。显然auto定义变量必须要有初始值。</li><li>一条生命一句只能有一种基本数据类型：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> sz = <span class="number">0</span>, pi =<span class="number">3.14</span>；<span class="comment">//错误,类型不⼀致</span></span><br></pre></td></tr></table></figure><h3 id="复合类型常量和auto">复合类型，常量和auto</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>, &amp;r = i; </span><br><span class="line"><span class="keyword">auto</span> a = r; <span class="comment">//推断a类型是int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//会忽略顶层const</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> ci = i;</span><br><span class="line"><span class="keyword">auto</span> b = ci;<span class="comment">//推断int，忽略顶层const</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> ci = <span class="number">1</span>; <span class="type">const</span> <span class="keyword">auto</span> f = ci;</span><br><span class="line"><span class="comment">//推断类型是int，如果希望是顶层const需要⾃⼰加const</span></span><br></pre></td></tr></table></figure><h2 id="decltype类型提示符c-11">DECLTYPE类型提示符(C++ 11)</h2><p><code>decltype</code> 是一个 C++11中引入的关键字，用于获取表达式的类型。它的语法如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">decltype</span>(expression)</span><br></pre></td></tr></table></figure><p>其中，<code>expression</code>是一个表达式，可以是变量、函数调用、类型转换等。</p><p><code>decltype</code>的作用是根据表达式的类型推断出一个变量或表达式的类型，并且返回该类型。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">decltype</span>(x) y; <span class="comment">// y 的类型为 int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">square</span><span class="params">(<span class="type">double</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value * value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">decltype</span>(<span class="built_in">square</span>(<span class="number">3.14</span>)) result; <span class="comment">// result 的类型为 double</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Point p;</span><br><span class="line"><span class="keyword">decltype</span>(p.x) a; <span class="comment">// a 的类型为 int</span></span><br></pre></td></tr></table></figure><p>在上面的示例中，<code>decltype(x)</code> 返回 <code>int</code>类型，因为表达式 <code>x</code> 的类型是<code>int</code>。<code>decltype(square(3.14))</code> 返回<code>double</code> 类型，因为表达式 <code>square(3.14)</code>的返回类型是 <code>double</code>。<code>decltype(p.x)</code> 返回<code>int</code> 类型，因为 <code>p.x</code> 是 <code>Point</code>结构体的一个成员变量。</p><p><code>decltype</code>在编写泛型代码时非常有用，可以根据参数的类型来推断出函数的返回类型，避免手动指定返回类型。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">multiply</span><span class="params">(T a, U b)</span> -&gt; <span class="title">decltype</span><span class="params">(a * b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a * b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">5</span>;</span><br><span class="line">    <span class="type">double</span> y = <span class="number">3.14</span>;</span><br><span class="line">    <span class="keyword">auto</span> result = <span class="built_in">multiply</span>(x, y); <span class="comment">// result 的类型为 double</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的示例中，<code>multiply</code> 函数使用<code>decltype(a * b)</code>来推断返回类型，根据传入的参数类型，返回类型会自动推断为<code>double</code>。</p><p><code>decltype</code>是一个非常有用的关键字，可以让编译器根据表达式的类型来推断出变量或函数的类型，提高代码的灵活性和可读性。</p><ul><li><p>从表达式的类型推断出要定义的变量的类型。</p></li><li><p><strong>decltype</strong>：选择并返回操作数的数据类型,不计算表达式的值。</p></li></ul><p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">decltype</span>(<span class="built_in">f</span>()) sum = x; <span class="comment">//推断sum的类型是函数f的返回类型。</span></span><br></pre></td></tr></table></figure></p><ul><li>不会忽略顶层const。</li><li>如果对变量加括号，编译器会将其认为是⼀个表达式，<code>decltype((i))</code>得到结果为引用。</li><li>赋值是会产⽣引用的⼀类典型表达式，引用的类型就是左值的类型。也就是说，如果i 是 int，则表达式 i=x 的类型是 int&amp;。</li></ul><h1 id="自定义数据结构struct">自定义数据结构STRUCT</h1><blockquote><p>尽量不要把类定义和对象定义放在⼀ 起。如struct Student{}xiaoming,xiaofang;</p></blockquote><ul><li>类可以以关键字struct开始，紧跟类名和类体。</li><li>类数据成员：类体定义类的成员。</li><li>C++11：可以为类数据成员提供⼀个<strong>类内初始值</strong>（in-class initializer）。</li></ul><p>下面举例：</p><ul><li>定义Sales_data类：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Sales_data.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SALES_DATA_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SALES_DATA_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Sales_data</span> &#123;</span><br><span class="line">std::string bookNo;</span><br><span class="line"><span class="type">unsigned</span> units_sold = <span class="number">0</span>;</span><br><span class="line"><span class="type">double</span> revenue = <span class="number">0.0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><ul><li>使用sales_data类</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Sales_data.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Sales_data.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Sales_data data1, data2;</span><br><span class="line"><span class="comment">// code to read into data1 and data2</span></span><br><span class="line"><span class="type">double</span> price = <span class="number">0</span>; <span class="comment">// price per book, used to calculate total revenue</span></span><br><span class="line"><span class="comment">// read the first transactions: ISBN, number of books sold, price per b</span></span><br><span class="line">std::cin &gt;&gt; data1.bookNo &gt;&gt; data1.units_sold &gt;&gt; price;</span><br><span class="line"><span class="comment">// calculate total revenue from price and units_sold</span></span><br><span class="line">data1.revenue = data1.units_sold * price;</span><br><span class="line"><span class="comment">// read the second transaction</span></span><br><span class="line">std::cin &gt;&gt; data2.bookNo &gt;&gt; data2.units_sold &gt;&gt; price;</span><br><span class="line">data2.revenue = data2.units_sold * price;</span><br><span class="line"><span class="comment">// code to check whether data1 and data2 have the same ISBN</span></span><br><span class="line"><span class="comment">// and if so print the sum of data1 and data2</span></span><br><span class="line"><span class="keyword">if</span> (data1.bookNo == data2.bookNo) &#123;</span><br><span class="line"><span class="type">unsigned</span> totalCnt = data1.units_sold + data2.units_sold;</span><br><span class="line"><span class="type">double</span> totalRevenue = data1.revenue + data2.revenue;</span><br><span class="line"><span class="comment">// print: ISBN, total sold, total revenue, average price per book</span></span><br><span class="line">std::cout &lt;&lt; data1.bookNo &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; totalCnt</span><br><span class="line">          &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; totalRevenue &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (totalCnt != <span class="number">0</span>)</span><br><span class="line">std::cout &lt;&lt; totalRevenue / totalCnt &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;(no sales)&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// indicate success</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">// transactions weren&#x27;t for the same ISBN</span></span><br><span class="line">std::cerr &lt;&lt; <span class="string">&quot;Data must refer to the same ISBN&quot;</span></span><br><span class="line">          &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// indicate failure</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="编写自己的头文件">编写自己的头文件</h3><ul><li>头文件通常包含一些只能被定义⼀次的实体：类、const和constexpr变量。</li></ul><p>预处理器概述：</p><ul><li>预处理器（preprocessor）：确保头文件多次包含仍能安全⼯作。</li><li>当预处理器看到#include标记时，会用指定的头文件内容代替#include</li><li>头文件保护符（headerguard）：头文件保护符依赖于预处理变量的状态：已定义和未定义。<ul><li>#indef已定义时为真</li><li>#inndef未定义时为真</li><li>头文件保护符的名称需要唯⼀，且保持全部大写。养成良好习惯，不论是否该头文件被包含，都要加保护符。</li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SALES_DATA_H <span class="comment">//SALES_DATA_H未定义时为真</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SALES_DATA_H</span></span><br><span class="line">strct Sale_data&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;基本内置类型&quot;&gt;基本内置类型&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;不同的编译器和平台可能会有差异,下表为在Windows_X64环境下使用MinGw GCC
9.2.0 32_bit为例:&lt;/p&gt;
&lt;/blockquote&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr class=&quot;header&quot;&gt;
&lt;th style=&quot;text-align: center;&quot;&gt;类型&lt;/th&gt;
&lt;th style=&quot;text-align: center;&quot;&gt;含义&lt;/th&gt;
&lt;th style=&quot;text-align: center;&quot;&gt;最小尺寸&lt;/th&gt;
&lt;th style=&quot;text-align: center;&quot;&gt;范围&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr class=&quot;odd&quot;&gt;
&lt;td style=&quot;text-align: center;&quot;&gt;bool&lt;/td&gt;
&lt;td style=&quot;text-align: center;&quot;&gt;布尔类型&lt;/td&gt;
&lt;td style=&quot;text-align: center;&quot;&gt;8bits&lt;/td&gt;
&lt;td style=&quot;text-align: center;&quot;&gt;true或false&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;even&quot;&gt;
&lt;td style=&quot;text-align: center;&quot;&gt;char&lt;/td&gt;
&lt;td style=&quot;text-align: center;&quot;&gt;字符型&lt;/td&gt;
&lt;td style=&quot;text-align: center;&quot;&gt;8bits&lt;/td&gt;
&lt;td style=&quot;text-align: center;&quot;&gt;-2^7 ~ 2^7-1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;odd&quot;&gt;
&lt;td style=&quot;text-align: center;&quot;&gt;wchar_t&lt;/td&gt;
&lt;td style=&quot;text-align: center;&quot;&gt;宽字符&lt;/td&gt;
&lt;td style=&quot;text-align: center;&quot;&gt;16bits&lt;/td&gt;
&lt;td style=&quot;text-align: center;&quot;&gt;0 ~ 2^16 - 1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;even&quot;&gt;
&lt;td style=&quot;text-align: center;&quot;&gt;char16_t&lt;/td&gt;
&lt;td style=&quot;text-align: center;&quot;&gt;Unicode字符&lt;/td&gt;
&lt;td style=&quot;text-align: center;&quot;&gt;16bits&lt;/td&gt;
&lt;td style=&quot;text-align: center;&quot;&gt;0 ~ 2^16 - 1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;odd&quot;&gt;
&lt;td style=&quot;text-align: center;&quot;&gt;char32_t&lt;/td&gt;
&lt;td style=&quot;text-align: center;&quot;&gt;Unicode字符&lt;/td&gt;
&lt;td style=&quot;text-align: center;&quot;&gt;32bits&lt;/td&gt;
&lt;td style=&quot;text-align: center;&quot;&gt;0 ~ 2^32 - 1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;even&quot;&gt;
&lt;td style=&quot;text-align: center;&quot;&gt;short&lt;/td&gt;
&lt;td style=&quot;text-align: center;&quot;&gt;短整型&lt;/td&gt;
&lt;td style=&quot;text-align: center;&quot;&gt;16bits&lt;/td&gt;
&lt;td style=&quot;text-align: center;&quot;&gt;-2^15 ~ 2^15-1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;odd&quot;&gt;
&lt;td style=&quot;text-align: center;&quot;&gt;int&lt;/td&gt;
&lt;td style=&quot;text-align: center;&quot;&gt;整型&lt;/td&gt;
&lt;td style=&quot;text-align: center;&quot;&gt;32bits&lt;/td&gt;
&lt;td style=&quot;text-align: center;&quot;&gt;-2^31 ~ 2^31-1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;even&quot;&gt;
&lt;td style=&quot;text-align: center;&quot;&gt;long&lt;/td&gt;
&lt;td style=&quot;text-align: center;&quot;&gt;长整型&lt;/td&gt;
&lt;td style=&quot;text-align: center;&quot;&gt;32bits&lt;/td&gt;
&lt;td style=&quot;text-align: center;&quot;&gt;-2^31 ~ 2^31-1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;odd&quot;&gt;
&lt;td style=&quot;text-align: center;&quot;&gt;long long&lt;/td&gt;
&lt;td style=&quot;text-align: center;&quot;&gt;长整型&lt;/td&gt;
&lt;td style=&quot;text-align: center;&quot;&gt;64bits&lt;/td&gt;
&lt;td style=&quot;text-align: center;&quot;&gt;-2^63 ~ 2^63-1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;even&quot;&gt;
&lt;td style=&quot;text-align: center;&quot;&gt;float&lt;/td&gt;
&lt;td style=&quot;text-align: center;&quot;&gt;单精度浮点型&lt;/td&gt;
&lt;td style=&quot;text-align: center;&quot;&gt;32bits&lt;/td&gt;
&lt;td style=&quot;text-align: center;&quot;&gt;大约7位有效数字&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;odd&quot;&gt;
&lt;td style=&quot;text-align: center;&quot;&gt;double&lt;/td&gt;
&lt;td style=&quot;text-align: center;&quot;&gt;双精度浮点型&lt;/td&gt;
&lt;td style=&quot;text-align: center;&quot;&gt;64bits&lt;/td&gt;
&lt;td style=&quot;text-align: center;&quot;&gt;大约15位有效数字&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;even&quot;&gt;
&lt;td style=&quot;text-align: center;&quot;&gt;long double&lt;/td&gt;
&lt;td style=&quot;text-align: center;&quot;&gt;扩展精度浮点型&lt;/td&gt;
&lt;td style=&quot;text-align: center;&quot;&gt;96bits&lt;/td&gt;
&lt;td style=&quot;text-align: center;&quot;&gt;更高的有效数字&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;</summary>
    
    
    
    <category term="后端" scheme="http://lgq007.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="C++" scheme="http://lgq007.github.io/tags/C/"/>
    
    <category term="c" scheme="http://lgq007.github.io/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>C++中的引用</title>
    <link href="http://lgq007.github.io/2023/07/15/C++%E4%B8%AD%E7%9A%84%E5%BC%95%E7%94%A8/"/>
    <id>http://lgq007.github.io/2023/07/15/C++%E4%B8%AD%E7%9A%84%E5%BC%95%E7%94%A8/</id>
    <published>2023-07-15T05:00:17.000Z</published>
    <updated>2023-07-15T12:34:09.666Z</updated>
    
    <content type="html"><![CDATA[<h1 id="c中的引用">C++中的引用</h1><h2 id="前言">前言：</h2><p>​C++是C语言的继承，它可进行过程化程序设计(面向过程)，也可以进行以继承和多态为特点的面向对象的程序设计。<strong>引用</strong>(reference)是C++对C语言的重要扩充，旨在使用一种更为安全和简洁的操作方式，弥补C语言指针(pointer)中的一些不足之处。</p><span id="more"></span><h2 id="引用的概念">引用的概念</h2><p>​引用就是为某一个变量(目标)起一个别名，类似于C语言结构体中用<code>typedef</code>命令为结构体起别名。也就是说它是某个已经存在的变量的另一个名字。对引用的操作与对变量名的操作可达到一样的效果。</p><h2 id="引用的初始化">引用的初始化</h2><p>​ 变量类型标识符 &amp;引用名= 目标变量名</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> &amp;b = a;</span><br></pre></td></tr></table></figure><p>上述步骤即完成了对变量a的引用，需要注意的是，<code>&amp;</code>并不是C语言中的取地址操作符，而是起到标识作用，标识所定义的变量是一个引用，引用的声明完成之后，目标变量便有了两个名称，同时指向相同的一块内存地址。</p><h2 id="定义引用的注意事项">定义引用的注意事项</h2><ul><li>引用在定义时必须初始化，必须要有指向的对象。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> &amp;b;</span><br><span class="line"> b = a;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,b);</span><br><span class="line"></span><br><span class="line"><span class="comment">//[Error] &#x27;b&#x27; declared as reference but not initialized</span></span><br></pre></td></tr></table></figure><ul><li>引用在初始化时只能绑定左值，不能绑定临时对象、表达式结果和字面常量。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span>&amp; ref = x;</span><br><span class="line">ref = <span class="number">10</span>;   <span class="comment">// 修改 x 的值</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> y = <span class="number">15</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; ref = y;</span><br><span class="line"><span class="type">int</span> z = ref; <span class="comment">// 可通过间接引用访问 const 限定的变量的值</span></span><br><span class="line">ref = <span class="number">10</span>; <span class="comment">// 错误，不能通过引用修改 const 限定的变量的值</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">getElement</span><span class="params">(<span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr[index];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>&amp; ref = <span class="built_in">getElement</span>(<span class="number">2</span>); <span class="comment">// 引用函数返回的左值引用</span></span><br><span class="line">ref = <span class="number">10</span>; <span class="comment">// 修改数组元素的值</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>&amp; ref = <span class="number">5</span>;  <span class="comment">// 错误，不能引用字面常量</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span>&amp; ref = x + y; <span class="comment">// 错误，不能引用表达式结果</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> z = <span class="number">20</span>;</span><br><span class="line"><span class="type">int</span>&amp; ref = z;  <span class="comment">// 错误，不能直接引用 const 限定的变量的值。</span></span><br></pre></td></tr></table></figure><p>这里要注意const左值与右值的区别:</p><p>const 左值和 const 右值都是指被声明为 const的值，至于怎么辨别左右值，主要看此时const限定的变量所起到的作用，它们之间的关系是：</p><ul><li>const 左值：const 左值是指被声明为 const的左值，即不可修改的左值。它可以通过引用来访问，但不能通过引用来修改。例如：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> x = <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; ref = x; <span class="comment">// 引用 const 左值</span></span><br><span class="line"><span class="type">int</span> y = ref; <span class="comment">// 通过引用访问 const 左值</span></span><br><span class="line">ref = <span class="number">10</span>; <span class="comment">// 错误，不能通过引用修改 const 左值</span></span><br></pre></td></tr></table></figure><ul><li>const 右值：const 右值是指被声明为 const的右值，即不可修改的右值。它不能被引用，因为引用只能绑定到可修改的左值。例如：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> y = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span>&amp; ref = y; <span class="comment">// 错误，不能引用 const 右值</span></span><br></pre></td></tr></table></figure><p>需要注意的是，const 右值和 const 左值都是不可修改的，但它们的区别在于const 左值可以通过引用访问和修改，而 const 右值不能被引用。</p><h2 id="引用与指针的区别">引用与指针的区别</h2><ol type="1"><li>定义和初始化：指针需要通过使用星号(*)来声明和初始化，而引用则使用&amp;符号来声明和初始化。例如：</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span>* ptr = &amp;x; <span class="comment">// 指针的定义和初始化</span></span><br><span class="line"><span class="type">int</span>&amp; ref = x; <span class="comment">// 引用的定义和初始化</span></span><br></pre></td></tr></table></figure><ol start="2" type="1"><li>空值：指针可以被赋予空值（nullptr），表示指向空地址或无效地址。而引用必须在声明时初始化，并且不能为空。例如：</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* ptr = <span class="literal">nullptr</span>; <span class="comment">// 指针赋予空值</span></span><br><span class="line"><span class="comment">// int&amp; ref; // 错误，引用必须在声明时初始化</span></span><br></pre></td></tr></table></figure><ol start="3" type="1"><li>可修改性：指针可以重新指向其他地址，也可以修改所指向的值。而引用在初始化后不能改变绑定的对象，只能通过引用来修改所绑定的对象的值。例如：</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> y = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span>* ptr = &amp;x;</span><br><span class="line">ptr = &amp;y; <span class="comment">// 指针重新指向另一个地址</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span>&amp; ref = x;</span><br><span class="line"><span class="comment">// ref = &amp;y; // 错误，引用不能重新绑定到另一个对象</span></span><br><span class="line">ref = y; <span class="comment">// 通过引用修改绑定对象的值</span></span><br></pre></td></tr></table></figure><ol start="4" type="1"><li>空间和操作：指针占用一定的内存空间，用于存储地址信息，而引用不占用额外的内存空间，它只是变量的别名。指针可以进行指针运算和解引用操作，而引用不需要进行这些操作，它可以直接使用原始变量的操作符。例如：</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span>* ptr = &amp;x;</span><br><span class="line"><span class="type">int</span>&amp; ref = x;</span><br><span class="line"></span><br><span class="line">*ptr = <span class="number">10</span>; <span class="comment">// 指针解引用并修改所指向的值</span></span><br><span class="line">ref = <span class="number">15</span>; <span class="comment">// 直接通过引用修改绑定对象的值</span></span><br></pre></td></tr></table></figure><p>总结起来，指针和引用都是用于间接访问和操作变量的机制，但它们在定义和初始化、空值、可修改性以及空间和操作上有所不同。选择使用指针还是引用取决于具体的需求和使用场景。</p><h2 id="引用的应用">引用的应用</h2><p>引用的主要应用就是把它作为函数参数，以扩厂函数传递数据的功能，引用作函数参数时是区别于值传递与地址传递的引用传递。</p><p>利用引用传递可以克服值传递与地址传递中容易出现错误且可读性差的缺点，可直接操作变量，简单高效且可读性高。</p><h3 id="函数参数传递">函数参数传递：</h3><p>引用可以用作函数的参数，可以通过引用传递变量，以便在函数内部修改原始变量的值。这样可以避免复制大型对象的开销，并且可以实现对变量的直接修改。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">increment</span><span class="params">(<span class="type">int</span>&amp; num)</span> </span>&#123;</span><br><span class="line">    num++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">increment</span>(x); <span class="comment">// 通过引用传递参数</span></span><br><span class="line">    cout &lt;&lt; x &lt;&lt; endl; <span class="comment">// 输出 6</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="返回值优化">返回值优化：</h3><p>函数可以返回引用类型，以便返回对变量的引用，而不是复制变量的值。这样可以避免复制大型对象的开销，并且可以实现对返回值的直接修改。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">getMax</span><span class="params">(<span class="type">int</span>&amp; a, <span class="type">int</span>&amp; b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a &gt; b) ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">5</span>;</span><br><span class="line">    <span class="type">int</span> y = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span>&amp; maxRef = <span class="built_in">getMax</span>(x, y); <span class="comment">// 返回引用</span></span><br><span class="line">    maxRef = <span class="number">15</span>; <span class="comment">// 修改返回的引用</span></span><br><span class="line">    cout &lt;&lt; x &lt;&lt; endl; <span class="comment">// 输出 15</span></span><br><span class="line">    cout &lt;&lt; y &lt;&lt; endl; <span class="comment">// 输出 10</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="遍历容器">遍历容器：</h3><p>引用可以用于遍历容器，通过引用来获取容器中的元素，以便对元素进行修改。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; nums = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span>&amp; num : nums) &#123;</span><br><span class="line">    num *= <span class="number">2</span>; <span class="comment">// 修改容器中的元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;c中的引用&quot;&gt;C++中的引用&lt;/h1&gt;
&lt;h2 id=&quot;前言&quot;&gt;前言：&lt;/h2&gt;
&lt;p&gt;​
C++是C语言的继承，它可进行过程化程序设计(面向过程)，也可以进行以继承和多态为特点的面向对象的程序设计。&lt;strong&gt;引用&lt;/strong&gt;
(reference)是C++对C语言的重要扩充，旨在使用一种更为安全和简洁的操作方式，弥补C语言指针(pointer)中的一些不足之处。&lt;/p&gt;</summary>
    
    
    
    <category term="后端" scheme="http://lgq007.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="C++" scheme="http://lgq007.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>HTML导读</title>
    <link href="http://lgq007.github.io/2023/07/14/HTML%E5%AF%BC%E8%AF%BB/"/>
    <id>http://lgq007.github.io/2023/07/14/HTML%E5%AF%BC%E8%AF%BB/</id>
    <published>2023-07-14T14:32:51.000Z</published>
    <updated>2023-07-15T13:19:44.494Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述">概述</h2><p>HTML是网页使用的语言，定义了网页的结构和内容。浏览器访问网站，其实就是从服务器下载HTML 代码，然后渲染出网页。</p><p>HTML 的全名是“超文本标记语言”（HyperText MarkupLanguage），上个世纪90年代由欧洲核子研究中心的物理学家蒂姆·伯纳斯-李（TimBerners-Lee）发明。它的最大特点就是支持超链接，可以跳转到其他网页，从而构成了整个互联网。1999年，HTML4.01 版发布，成为广泛接受的 HTML 标准。2014年，HTML 5发布，这是目前正在使用的版本。</p><p>浏览器的网页开发，涉及三种技术：HTML、CSS 和 JavaScript。HTML语言定义网页的结构和内容，CSS 样式表定义网页的样式，JavaScript语言定义网页与用户的互动行为。</p><span id="more"></span><p>下面就是一个简单网页的 HTML 源码。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>网页标题<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面这段代码，可以保存成文件<code>hello.html</code>。浏览器打开这个本地文件，就能看到文字“HelloWorld”。</p><h2 id="网页的基本概念">网页的基本概念</h2><h3 id="标签">标签</h3><p>HTML 代码由许许多多不同的标签（tag）构成。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>网页标题<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>&lt;title&gt;</code>和<code>&lt;/title&gt;</code>就是一对标签。</p><p>标签用来告诉浏览器，如何处理这段代码。标签的内容就是浏览器所要渲染的、展示在网页上的内容。</p><p><strong>标签放在一对尖括号里面（比如<code>&lt;title&gt;</code>），大多数标签都是成对出现的，分成开始标签和结束标签，结束标签在标签名之前加斜杠（比如<code>&lt;/title&gt;</code>）。但是，也有一些标签不是成对使用，而是只有开始标签，没有结束标签，比如上一节示例的<code>&lt;meta&gt;</code>标签。</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>&lt;meta&gt;</code>标签就没有结束标签<code>&lt;/meta&gt;</code>。</p><p>这种单独使用的标签，通常是因为标签本身就足够完成功能了，不需要标签之间的内容。实际引用中，它们主要用来提示浏览器，做一些特别处理。</p><p>标签可以嵌套。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span> <span class="tag">&lt;<span class="name">p</span>&gt;</span>hello world<span class="tag">&lt;/<span class="name">p</span>&gt;</span> <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>&lt;div&gt;</code>标签内部包含了一个<code>&lt;p&gt;</code>标签。</p><p>嵌套时，必须保证正确的闭合顺序，不能跨层嵌套，否则会出现意想不到的渲染结果。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span> <span class="tag">&lt;<span class="name">p</span>&gt;</span>hello world<span class="tag">&lt;/<span class="name">div</span>&gt;</span> <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面代码就是错误的嵌套，闭合顺序不正确。</p><p><strong>标签名是大小写不敏感，比如<code>&lt;title&gt;</code>和<code>&lt;TITLE&gt;</code>是同一个标签。不过，一般习惯都是使用小写。</strong></p><p>另外，HTML语言忽略缩进和换行。也就是说，下面的写法与一行的写法效果是一样的。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>  网页标题<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br></pre></td></tr></table></figure><p>进一步说，整个网页的 HTML代码完全可以写成一行，浏览器照样解析，结果完全一样。有时，正式发布网页之前，开发者会把源码压缩成一行，以减少传输的字节数。网页内容的缩进和换行，主要靠CSS 样式来实现。</p><h3 id="元素">元素</h3><p>浏览器渲染网页的时候，会把 HTML源码解析成一个标签树，每个标签都是一个节点（node），称为网页元素（element）。所以，“标签”和“元素”基本上是同义词，只是使用的场合不一样：标签是源码角度来看，元素是从编程角度来看，比如<code>&lt;p&gt;</code>标签对应网页的<code>p</code>元素。</p><p>嵌套的标签就构成了网页元素的层级关系。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span> <span class="tag">&lt;<span class="name">p</span>&gt;</span>hello world<span class="tag">&lt;/<span class="name">p</span>&gt;</span> <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>div</code>元素内部包含了一个<code>p</code>元素。上层元素又称为“父元素”，下层元素又称为“子元素”，即<code>div</code>是<code>p</code>的父元素，<code>p</code>是<code>div</code>的子元素。</p><p><strong>所有元素可以分成两大类：块级元素（block）和行内元素（inline）。块级元素默认占据一个独立的区域，在网页上会自动另起一行，占据100% 的宽度。</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>world<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>p</code>元素是块级元素，因此浏览器会将内容分成两行显示。</p><p><strong>行内元素默认与其他元素在同一行，不产生换行。比如，<code>span</code>就是行内元素，通常用来为某些文字指定特别的样式。</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>world<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>上面代码中，<code>span</code>元素是行内元素，因此浏览器会将两行内容放在一行显示。</strong></p><h3 id="属性">属性</h3><p><strong>属性（attribute）是标签的额外信息，使用空格与标签名和其他属性分隔。</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;demo.jpg&quot;</span> <span class="attr">width</span>=<span class="string">&quot;500&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>&lt;img&gt;</code>标签有两个属性：<code>src</code>和<code>width</code>。</p><p>属性可以用等号指定属性值，比如上例的<code>demo.jpg</code>就是<code>src</code>的属性值。<strong>属性值一般放在双引号里面，这不是必需的，但推荐总是使用双引号。</strong></p><p><strong>注意，属性名是大小写不敏感的，<code>onclick</code>和<code>onClick</code>是同一个属性。</strong></p><p>HTML 提供大量属性，用来定制标签的行为。</p><h2 id="网页的基本标签">网页的基本标签</h2><p>符合语法标准的网页，应该满足下面的基本结构。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>不管多么复杂的网页，都是从上面这个基本结构衍生出来的。</p><p><strong>注意，HTML代码的缩进和换行，对于浏览器不产生作用。所以，上面的代码完全可以写成一行，渲染结果不变。上面这样分行写，只是为了提高可读性。</strong></p><p>下面介绍，这个基本结构的主要标签，它们构成网页的骨架。</p><h3 id="doctype">&lt;!doctype&gt;`</h3><p>网页的第一个标签通常是<code>&lt;!doctype&gt;</code>，表示文档类型，告诉浏览器如何解析网页。</p><p>一般来说，只要像下面这样，简单声明<code>doctype</code>为<code>html</code>即可。浏览器就会按照HTML5 的规则处理网页。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!doctype <span class="keyword">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>有时，该标签采用完全大写的形式，以便区别于正常的 HTML标签。因为<code>&lt;!doctype&gt;</code>本质上不是标签，更像一个处理指令。</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="html"><code>&lt;html&gt;</code></h3><p><strong><code>&lt;html&gt;</code>标签是网页的顶层容器，也称为根元素（rootelement），其他元素都是它的子元素。一个网页只能有一个<code>&lt;html&gt;</code>标签。</strong></p><p><strong>该标签的<code>lang</code>属性，表示网页内容默认的语言。</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面代码表示，网页的语言是英语。更详细的介绍，参见《属性》一章。</p><h3 id="head"><code>&lt;head&gt;</code></h3><p><code>&lt;head&gt;</code>标签是一个容器标签，用于放置网页的元信息。它的内容不会出现在网页上，而是为网页渲染做准备。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!doctype <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span>    </span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>网页标题<span class="tag">&lt;/<span class="name">title</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>&lt;head&gt;</code>是<code>&lt;html&gt;</code>的第一个子元素。如果网页不包含<code>&lt;head&gt;</code>，浏览器会自动创建一个。</p><p><code>&lt;head&gt;</code>的子元素一般有下面七个，后文会一一介绍。</p><ul><li><strong><code>&lt;meta&gt;</code>：设置网页的元数据。</strong></li><li><strong><code>&lt;link&gt;</code>：连接外部样式表。</strong></li><li><strong><code>&lt;title&gt;</code>：设置网页标题。</strong></li><li><strong><code>&lt;style&gt;</code>：放置内嵌的样式表。</strong></li><li><strong><code>&lt;script&gt;</code>：引入脚本。</strong></li><li><strong><code>&lt;noscript&gt;</code>：浏览器不支持脚本时，所要显示的内容。</strong></li><li><strong><code>&lt;base&gt;</code>：设置网页内部相对 URL的计算基准。</strong></li></ul><h3 id="meta"><code>&lt;meta&gt;</code></h3><code>&lt;meta&gt;</code>标签用于设置或说明网页的元数据，必须放在<head>里面。一个<meta>标签就是一项元数据，网页可以有多个<meta><p>。</p><p>一般来说，网页至少应该具有以下两个<code>&lt;meta&gt;</code>标签，而且必须在<code>&lt;head&gt;</code>的最前面。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1&quot;</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>Page Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>（1）charset 属性</strong><code>&lt;meta&gt;</code>有一个charset属性，指定网页的编码方式，该属性非常重要。如果设置得不正确，浏览器可能无法正确解码，就会出现乱码。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面代码声明，网页为<code>utf-8</code>编码。虽然可以使用其他的编码方式，但几乎总是应该采用UTF-8。注意，声明的编码方式，应该与网页实际的编码方式一致，即声明了<code>utf-8</code>，网页就应该使用UTF-8 编码保存。</p><p><strong>（2）name 属性，content 属性</strong></p><p><code>&lt;meta&gt;</code>的name属性表示元数据的名字，content属性表示元数据的值。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;description&quot;</span> <span class="attr">content</span>=<span class="string">&quot;HTML 语言入门&quot;</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;keywords&quot;</span> <span class="attr">content</span>=<span class="string">&quot;HTML,教程&quot;</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;author&quot;</span> <span class="attr">content</span>=<span class="string">&quot;张三&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面代码包含了三个元数据：<strong><code>description</code>是网页内容的描述，<code>keywords</code>是网页内容的关键字，<code>author</code>是网页作者。</strong></p><p>元数据有很多种，大部分涉及浏览器内部工作机制，或者特定的使用场景，这里就不一一介绍了。下面是一些例子。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;application-name&quot;</span> <span class="attr">content</span>=<span class="string">&quot;Application Name&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;generator&quot;</span> <span class="attr">content</span>=<span class="string">&quot;program&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;subject&quot;</span> <span class="attr">content</span>=<span class="string">&quot;your document&#x27;s subject&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;referrer&quot;</span> <span class="attr">content</span>=<span class="string">&quot;no-referrer&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>（3）http-equiv 属性，content 属性</strong></p><p><code>http-equiv</code>属性用来覆盖 HTTP回应的头信息字段，<code>content</code>属性是该字段的内容。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;default-src &#x27;self&#x27;&quot;&gt;</span><br></pre></td></tr></table></figure><p>上面代码可以覆盖 HTTP回应的<code>Content-Security-Policy</code>字段。</p><p>下面是另一些例子。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;Content-Type&quot;</span> <span class="attr">content</span>=<span class="string">&quot;Type=text/html; charset=utf-8&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;refresh&quot;</span> <span class="attr">content</span>=<span class="string">&quot;30&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;refresh&quot;</span> <span class="attr">content</span>=<span class="string">&quot;30;URL=&#x27;http://website.com&#x27;&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="title"><code>&lt;title&gt;</code></h3><p><strong><code>&lt;title&gt;</code>标签用于指定网页的标题，会显示在浏览器窗口的标题栏。</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>网页标题<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure><p>搜索引擎根据这个标签，显示每个网页的标题。它对于网页在搜索引擎的排序，有很大的影响，应该精心安排，反映网页的主题。</p><p><code>&lt;title&gt;</code>标签的内部，不能再放置其他标签，只能放置无格式的纯文本。</p><h3 id="body"><code>&lt;body&gt;</code></h3><p><strong><code>&lt;body&gt;</code>标签是一个容器标签，用于放置网页的主体内容。浏览器显示的页面内容，都是放置在它的内部。它是<code>&lt;html&gt;</code>的第二个子元素，紧跟在<code>&lt;head&gt;</code>后面。</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span>    </span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>网页标题<span class="tag">&lt;/<span class="name">title</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span>    </span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>hello world<span class="tag">&lt;/<span class="name">p</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="空格和换行">空格和换行</h2><p>HTML语言有自己的空格处理规则。标签内容的头部和尾部的空格，一律忽略不计。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>  hello world   <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>hello</code>前面的空格和<code>world</code>后面的空格，浏览器一律忽略不计。</p><p><strong>标签内容里面的多个连续空格（包含制表符<code>\t</code>），会被浏览器合并成一个。</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>hello      world<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>hello</code>与<code>world</code>之间有多个连续空格，浏览器会将它们合并成一个。网页渲染的结果是，<code>hello</code>与<code>world</code>之间只有一个空格。</p><p><strong>浏览器还会将文本里面的换行符（<code>\n</code>）和回车符（<code>\r</code>），替换成空格。</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>hello</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">world<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>hello</code>与<code>world</code>之间有多个换行，浏览器会将它们替换成空格，然后再将多个空格合并成一个。网页渲染的结果是，<code>hello</code>与<code>world</code>之间有一个空格。</p><p>这意味着，HTML 源码里面的换行，不会产生换行效果。</p><h2 id="注释">注释</h2><p>HTML代码可以包含注释，浏览器会自动忽略注释。注释以<code>&lt;!--</code>开头，以<code>--&gt;</code>结尾，下面就是一个注释的例子。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 这是一个注释 --&gt;</span><br></pre></td></tr></table></figure><p>注释可以是多行的，并且内部的 HTML 都不再生效了。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--  </span></span><br><span class="line"><span class="comment">&lt;p&gt;</span></span><br><span class="line"><span class="comment">hello world</span></span><br><span class="line"><span class="comment">&lt;/p&gt;</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br></pre></td></tr></table></figure><p>上面代码是一个注释的区块，内部的代码都是无效的，浏览器不会解析，更不会渲染它们。</p><p>注释有助于理解代码的含义，复杂的代码块前面最好加上注释。</p></head>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;概述&quot;&gt;概述&lt;/h2&gt;
&lt;p&gt;HTML
是网页使用的语言，定义了网页的结构和内容。浏览器访问网站，其实就是从服务器下载
HTML 代码，然后渲染出网页。&lt;/p&gt;
&lt;p&gt;HTML 的全名是“超文本标记语言”（HyperText Markup
Language），上个世纪90年代由欧洲核子研究中心的物理学家蒂姆·伯纳斯-李（Tim
Berners-Lee）发明。它的最大特点就是支持超链接，可以跳转到其他网页，从而构成了整个互联网。1999年，HTML
4.01 版发布，成为广泛接受的 HTML 标准。2014年，HTML 5
发布，这是目前正在使用的版本。&lt;/p&gt;
&lt;p&gt;浏览器的网页开发，涉及三种技术：HTML、CSS 和 JavaScript。HTML
语言定义网页的结构和内容，CSS 样式表定义网页的样式，JavaScript
语言定义网页与用户的互动行为。&lt;/p&gt;</summary>
    
    
    
    <category term="前端" scheme="http://lgq007.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="html" scheme="http://lgq007.github.io/tags/html/"/>
    
  </entry>
  
</feed>
